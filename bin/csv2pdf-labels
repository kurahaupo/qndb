#!/usr/bin/perl

use 5.008;
use strict;
use warnings;
use utf8;

use PDF::API2;
use Text::CSV;
use Getopt::Long qw(:config auto_abbrev bundling);
use Data::Dumper;

use constant pt => 1;
use constant px => 2/3;
use constant in => 72;
use constant mm => 72 / 25.4;
use constant golden_mean => (sqrt(5)+1)/2;  # (= Φ, phi)

my $verbose = 0;

################################################################################

#
# manage the pdf pagination outside the main loop;
# font selections reside within a current page;...
#
{
package PDF_paginator;

sub new {
    my $class = shift;
    my ($page_size) = @_;
    my $p = bless { page_size => $page_size }, $class;
    warn "Next Page\n" if $verbose;
    $p->_startpage;
    return $p;
}

sub pdf {
    my $p = shift;
    $p->{pdf} ||= PDF::API2->new(@_)
}

sub _startpage {
    my $p = shift;
    my $pdf = $p->pdf;
    warn "Next Page\n" if $verbose;
    my $page = $p->{page} = $pdf->page(@_);
    $page->mediabox($p->{page_size});
    ( undef, undef, $p->{page_width}, $p->{page_height} ) = $page->get_mediabox();
    $p->{page_item_num} = 0;
}

# start a page if none currently, otherwise use current page
sub page {
    my $p = shift;
    $p->_startpage if ! $p->{page};
    $p->{page};
}

# close the current page, so that the next call to "page" will start a new page
sub closepage {
    my $p = shift;
    #$p->{page} or return;  # no current page
    delete $p->{text};
    delete $p->{page};
}

# get the "text" attribute of the current page (starting a new page if necessary)
sub text {
    my $p = shift;
    $p->{text} ||= $p->page->text();
}

sub corefont {
    my $p = shift;
    my $name = shift;
    $p->{fontcache}{$name} ||= $p->pdf->corefont($name);
}

sub pages {
    my $p = shift;
    $p->{pdf} && $p->{pdf}->pages || 0
}

sub stringify {
    my $p = shift;
    $p->{pdf} or return;
    $p->closepage;
    my $r = $p->{pdf}->stringify;
    %$p = ();
    $r;
}

sub write_into {
    my $p = shift;
    my $filename = shift;
    my $pdf = $p->{pdf} or return;
    $pdf->saveas($filename);
}

#sub DESTROY { }
}

################################################################################

my $banner_scale = golden_mean;
my $force_overwrite = 1;
my $fontsize = 12*pt;
my $instruction_colour = 'orange';
my $label_bottom_margin = 4*mm;
my $label_height;
my $label_left_margin = 1*mm;
my $label_right_margin = 1*mm;
my $label_step_across;
my $label_step_down;
my $label_top_margin = 4*mm;
my $label_width;
my $line_spacing = 1.25;
my $page_size = 'a4';
my $labels_across = 3;
my $labels_down = 7;
my $page_bottom_margin = 14*mm;
my $page_left_margin = 0;
my $page_right_margin = 0;
my $page_top_margin = 14*mm;
my $postcode_fontsize = 14;
my $x_start = 0;
my $y_start = 0;
my %skip_inserts = map { ( $_ => 1 ) } 'mt_eden_minutes';
my @rd_binmode;

sub min(@) { my $r = shift; $r < $_ or $r = $_ for @_; $r }
sub max(@) { my $r = shift; $r > $_ or $r = $_ for @_; $r }
sub sum(@) { my $r = shift; $r += $_ for @_; $r }

{

my %units = (
    cm => 0.1*mm,
    in => in,
    m  => 1000*mm,
    mm => mm,
    pt => pt,
    px => px,
    μm => 0.001*mm,
);

my %paper_sizes = (
        (map {
            (my $x = $_) =~ s/^a//i;
            my $h = 2**(0.25-$x/2);
            my $w = $h / sqrt(2);
            ( ( $_ < 0 ? (2**-$_).'a0' : "a$_") => [ $w, $h ] );
        } -2 .. 10),
        (map {
            (my $x = $_) =~ s/^b//i;
            my $h = 2**(0.5-$x/2);
            my $w = $h / sqrt(2);
            ( ( $_ < 0 ? (2**-$_).'b0' : "b$_") => [ $w, $h ] );
        } 0 .. 10),
        (map {
            (my $x = $_) =~ s/^c//i;
            my $w = 2**(0.375-$x/2);
            my $h = $w / sqrt(2);
            ( ( $_ < 0 ? (2**-$_).'c0' : "c$_") => [ $w, $h ] );    # landscape
        } 0 .. 10),
        dl => [ 220, 110 ],                                         # landscape
    );
print Dumper(\%paper_sizes) if 0;

sub as_points($) {
    my $v = $_[0];
    if ($v =~ s/[a-z]+$//) {
        $v *= $units{$&} || die "Unknown unit-of-measure $&\n";
    }
    $v;
}

my %label_product = (
    'avery-l7160-shrink' => {
            page_size            => 'a4',
            labels_across        => 3,
            labels_down          => 7,
            page_top_margin      => as_points '5mm',
            page_bottom_margin   => as_points '-1mm',
            page_left_margin     => as_points '0mm',
            page_right_margin    => as_points '-6mm',
            label_top_margin     => as_points '1mm',
            label_bottom_margin  => as_points '3mm',
            label_left_margin    => as_points '3mm',
            label_right_margin   => as_points '3mm',
        },
    'avery-l7160' => {
            page_size            => 'a4',
            labels_across        => 3,
            labels_down          => 7,
            page_top_margin      => as_points '17mm',
            page_bottom_margin   => as_points '13mm',
            page_left_margin     => as_points '5mm',
            page_right_margin    => as_points '6mm',
            label_top_margin     => as_points '1.5mm',
            label_bottom_margin  => as_points '1.5mm',
            label_left_margin    => as_points '5.7mm',
            label_right_margin   => as_points '7.7mm',
        },
    );
sub use_preset {
    my $p = $label_product{$_[1]} || die "Unknown label product '$_[1]'\n";
    (
        $page_size, $labels_across, $labels_down,
        $page_top_margin, $page_bottom_margin, $page_left_margin, $page_right_margin,
        $label_top_margin, $label_bottom_margin, $label_left_margin, $label_right_margin,
    ) = @$p{qw{
        page_size labels_across labels_down
        page_top_margin page_bottom_margin page_left_margin page_right_margin
        label_top_margin label_bottom_margin label_left_margin label_right_margin
    }};
}

sub M($) {
    my $r = \$_[0];
    sub { $$r = as_points $_[-1] }
}

sub N($) {
    my $r = \$_[0];
    sub { $$r = ! $_[1] }
}

my $use_bom;
my $use_crlf;
my $use_encoding;
GetOptions
    'P|preset=s'    => \&use_preset,
    'a=i'           => sub { $page_size = $_[0].$_[1] },
    'b=i'           => sub { $page_size = $_[0].$_[1] },
    'bom|B!'        => \$use_bom,
    'color|colour=s' => \$instruction_colour,
    'encoding|E=s'  => \$use_encoding,
    'insert=s'      => sub { (my $a = lc $_[1]) =~ s/\W+/_/g; $skip_inserts{$a} = 0 },
    'latin|eo|O'    => sub { $use_encoding = undef },
    'lh=s'          => M$label_height,
    'lw=s'          => M$label_width,
    'lxh=s'         => M$label_step_down,
    'lxw=s'         => M$label_step_across,
    'na=i'          => \$labels_across,
    'nd=i'          => \$labels_down,
    'skip-insert=s' => sub { (my $a = lc $_[1]) =~ s/\W+/_/g; $skip_inserts{$a} = 1 },
    'utf16be|eb|B'  => sub { $use_encoding = "UTF-16BE" },
    'utf16le|el|L'  => sub { $use_encoding = "UTF-16LE" },
    'utf8|eu|U'     => sub { $use_encoding = "UTF-8" },
    'v+'            => \$verbose,
    'xo=s'          => M$x_start,
    'yo=s'          => M$y_start,
    or exit 64;

$use_encoding and push @rd_binmode, ":encoding($use_encoding)";
$use_crlf and push @rd_binmode, ":crlf";
unshift @rd_binmode, " :raw" if @rd_binmode;
$use_bom and push @rd_binmode, ":bom";
warn "BINMODE=@rd_binmode\n" if $verbose && @rd_binmode;
}

$x_start += $label_left_margin + $page_left_margin;
$y_start += $label_top_margin + $page_top_margin;

################################################################################

{
package CommonLabel;
sub fix_one {
    my $r = shift;
    1;
}
}

{
package HouseholdLabel;
our @ISA = CommonLabel::;
sub fix_one {
    my $r = shift;
    $r->SUPER::fix_one(@_);
    1;
}

sub render {
    my $r = shift;
}
}

{
package InfoLabel;
our @ISA = CommonLabel::;
sub fix_one {
    my $r = shift;
    $r->SUPER::fix_one(@_);
    my @inserts = grep { (my $a = lc $_) =~ s/\W+/_/g; ! $skip_inserts{$a} } sort split /\s*,\s*/, $r->{inserts} // '';
    $r->{inserts} = join ',', @inserts;
    $r->{LIST_insert} = \@inserts;
    $r->{HAS_insert} = { map { ( $_ => 1 ) } @inserts };
}

sub render {
    my $r = shift;
}
}

sub process_file($$) {
    my $infile = shift;
    my $outfile = shift;

    my $inname = "(stdin)";
    if (!ref $infile) {
        $inname = $infile;
        $infile = undef;
        open $infile, "<@rd_binmode", $inname or die "Can't open $inname; $!\n";
    }

    my @headers;
    my @records;
    my %record_by_uid;
    my %record_by_name;

    my $csv = Text::CSV::->new({ sep_char => "\t", binary => 1 }) or die "Can't construct CSV reader; $!";

    {
    my $r0 = $csv->getline($infile) or die "Can't get header line from $inname\n";
    print "Read headers: " . Dumper($r0) if $verbose > 2;
    $r0->[0] =~ s/^\ufeff//;     # kill Byte-Order-Mark
    $r0->[0] =~ s/^!//;          # kill the ! used to force headers to sort to beginning of file
    $r0->[0] =~ s/^_//;          # kill various random characters which get mapped, including ! and BOM
    @headers = map { s/\W+/_/g; lc $_ } @$r0;
    print "Parsed headers: " . Dumper(\@headers) if $verbose > 2;
    }

    my $summary_record;
    my $curr_inserts;
    my @curr_inserts;
    my %count_inserts;
    RECORD:while ( my $ra = $csv->getline($infile) ) {
        $#$ra >= 0 or next;  # skip blank lines
        $#$ra <= $#headers or warn "Line $. has $#$ra fields, but headers had $#headers\n";

        my %rh;
        @rh{@headers} = @$ra;
        my $r = bless \%rh, HouseholdLabel::;
        $r->fix_one;
        $r->{inserts} ||= '(none)';
        if (scalar(@records) % ($labels_across*$labels_down) == 0
          || !defined $curr_inserts
          || $r->{inserts} ne $curr_inserts) {
            $curr_inserts = $r->{inserts};
            @curr_inserts = split /[,\n]/, $curr_inserts;
            @curr_inserts or @curr_inserts = 'none';
                push @records, $summary_record = bless { page_info => 'next %{count}u -->',
                                    map { ( "address$_" => $curr_inserts[$_] ) } 0 .. $#curr_inserts }, InfoLabel::;
        }
        push @records, $r;
        ++$count_inserts{$_} for @curr_inserts;
        ++$summary_record->{count};
        if (my $uid = $r->{uid}) { $record_by_uid{$uid} = $r }
        if (my $name = $r->{name}) { $record_by_name{$name} = $r }
    }
    my @insert_types = sort keys %count_inserts;
    push @records, bless { page_info => 'count',
                           map { ( "address$_" => "$insert_types[$_]: $count_inserts{$insert_types[$_]}" ) } 0 .. $#insert_types },
                        InfoLabel::;
    warn "STOPPED file on line $.\n" if $verbose;
    close $infile or die "Error while reading $inname; $!\n";

    my $pq = new PDF_paginator:: ($page_size);
    my $page_width = $pq->{page_width};
    my $page_height = $pq->{page_height};

    {
    my $printable_page_height = $page_height - $page_top_margin - $page_bottom_margin;
    my $printable_page_width  = $page_width  - $page_left_margin - $page_right_margin;

    $labels_across ||= $printable_page_width  / ($label_step_across || $label_width);
    $labels_down   ||= $printable_page_height / ($label_step_down   || $label_height);

    $label_step_across ||= $printable_page_width  / $labels_across || $label_height + $label_top_margin + $label_bottom_margin;
    $label_step_down   ||= $printable_page_height / $labels_down   || $label_width  + $label_left_margin + $label_right_margin;

    $label_height ||= $label_step_down   -  $label_top_margin - $label_bottom_margin;
    $label_width  ||= $label_step_across -  $label_left_margin - $label_right_margin;

    warn sprintf "First Page\n"
               . "page size: %.2fmm x %.2fmm (%s)\n"
               . "printable page size: %.2fmm x %.2fmm\n"
               . "labels/page: %s x %s\n"
               . "label size: %.2fmm x %.2fmm\n"
               . "label step: %.2fmm x %.2fmm\n"
               ,
                $page_width/mm, $page_height/mm, $page_size,
                $printable_page_width/mm, $printable_page_height/mm,
                $labels_across, $labels_down,
                $label_width/mm, $label_height/mm,
                $label_step_across/mm, $label_step_down/mm,
        if $verbose;
    }

    my $font      = $pq->corefont('Helvetica');
    my $bold_font = $pq->corefont('Helvetica-Bold');

    for my $r ( @records ) {
        my $text = $pq->text;

        my $label_on_page = $pq->{page_item_num}++;

        my $col  = $label_on_page % $labels_across;
        my $row  = ($label_on_page-$col) / $labels_across;
        my $top  = $page_height - $y_start - $label_step_down * $row;
        my $left =                $x_start + $label_step_across * $col;

        my @lines = map { $r->{$_} || () } qw{ name care_of address0 address1 address2 address3 address4 country };

        my $nlines = @lines;
        my $active_fontsize = min $fontsize, $label_height / $nlines / $line_spacing;
        if (my $p = $r->{page_info}) {
            if (my @v = $p =~ m/\%\{(\w+)\}/g) {
                warn "format '$p' keys [@v]\n" . Dumper($r) if $verbose > 2;
                $p =~ s/\%\{(\w+)\}/%/g;
                $p = sprintf $p, @$r{@v};
            }
            $nlines += $banner_scale;
            $active_fontsize = min $fontsize, $label_height / $nlines / $line_spacing;
            my $banner_fontsize = $active_fontsize*$banner_scale;
            $text->font( $bold_font, $banner_fontsize );
            $text->fillcolor($instruction_colour);
            $text->translate( $left, $top - $banner_fontsize*$line_spacing );
            $text->text($p);
        } else {
            $text->fillcolor('black');
        }
        $text->font( $font, $active_fontsize );
        for (0 .. $#lines) {
            $text->translate( $left, $top - ($nlines - $#lines + $_)*$active_fontsize*$line_spacing );
            $text->text($lines[$_]);
        }
        if (my $p = $r->{postcode}) {
            $text->font( $bold_font, $postcode_fontsize );
            $text->translate( $left + $label_width, $top - $label_height + $postcode_fontsize );
            $text->text_right($p);
        }

        warn sprintf "Page %u label %u row %u/%u column %u/%u: lines=%u font=%.2fmm (%.2fpt)\n",
                $pq->pages,
                $label_on_page,
                $row, $labels_across, $col, $labels_down,
                $nlines, $active_fontsize/mm, $active_fontsize if $verbose > 1;
        if ($label_on_page+1 >= $labels_across * $labels_down) {
            warn "Throwpage\n" if $verbose > 1;
            $pq->closepage;
        }
    }

    if (!ref $outfile) {
        ! -e $outfile or $force_overwrite or die "Destination file $outfile already exists (when processing $inname)!\n";
        $pq->write_into($outfile) or die "Couldn't save to '$outfile'; $!\n";
    } else {
        print {$outfile} $pq->stringify;
        flush $outfile or die "Error while writing to stdout; $!\n";
    }
}

process_file *STDIN{IO}, *STDOUT{IO} if !@ARGV;
for my $in (@ARGV) {
    (my $out = $in) =~ s/\.\w*$//;
    $out .= '.pdf';
    process_file $in, $out
}

1;
