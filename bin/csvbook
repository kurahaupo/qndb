#!/bin/bash

. $HOME/Quakers/lib/qlib.bash

once=false

bookfile=

book_opts=()

use_sql=false
sql_dsn=dbi:mysql:quakers

set_opt() {
    declare -n a=$1
    declare o=$2
    [[ $o = *[!ilamw]* ]] && return 1
    [[ $o = *[il]*  ]] || o+=il
    [[ $o = *[amw]* ]] || o+=amw
    [[ $o = *l* && $o = *a* ]] && a+=( --book-listing-all   )
    [[ $o = *l* && $o = *m* ]] && a+=( --book-listing-by-mm )
    [[ $o = *l* && $o = *w* ]] && a+=( --book-listing-by-wg )
    [[ $o = *i* && $o = *a* ]] && a+=( --book-index-all     )
    [[ $o = *i* && $o = *m* ]] && a+=( --book-index-by-mm   )
    [[ $o = *i* && $o = *w* ]] && a+=( --book-index-by-wg   )
    return 0
}

one_input=

for o do
    case $o in
    (-S|--sql)                  use_sql=true sql_dsn=dbi: ;;
    (--sql*)                    use_sql=true sql_dsn=${o#*=} book_opts+=("$o");;
    (dbi:*)                     use_sql=true sql_dsn=$o ;;
    (-1|--once)                 once=true ;;
    (--loop)                    once=false ;;
    (-n)                        book_opts=() ;;
    (-x)                        set -x ;;
    (--style=*)                 set_opt book_opts "${o#*=}" ||
                                die EX_USAGE "Invalid style '${o#*=}'" ;;
    (-*)                        book_opts+=("$o") ;;
    (*.csv)                     once=true one_input=$o ;;
    (*)                         die EX_USAGE "Invalid option '$o'" ;;
    esac
done

if (( use_sql ))
then
    for v in QDB_USER QDB_PASSFILE QDB_HOST QDB_PORT; do
        [[ ${!v} ]] || die EX_UNAVAILABLE "Environment is missing $v"
    done
fi

while
    desc=( "${book_opts[@]#--book-}" )
    desc=( "${desc[@]/?(ndex|isting)?(-by)-/x\/}" )
    ((once)) || {
    printf >&2 'Book [%s]? ([il][amw]|yes|quit|help) ' "${desc[*]}"
    read oo && [[ $oo != @(q|quit|stop|exit|halt|fg) ]]
    }
do

    [[ help = "$oo"* && $oo = h* || $oo = '?'* ]] && { cat <<EndOfHelp ; continue ; }
bundles of letters:
 i - index
 l - listing
 a - unified (single group)
 m - group by MM
 w - group by WG
eg:
 iam wl - unified index, index by MM, listing by WG
 ia lmw - unified index, listing by MM, listing by WG
 i - unified index, index by MM, index by WG
 a - unified index & unified listing
EndOfHelp

    cur_book_opts=( "${book_opts[@]}" )

    if (( use_sql ))
    then
        set_current_vars
        input_file=$sql_dsn
        bookfile=${dbdir}qdb-$today-book.pdf
    elif [[ $one_input ]]
    then
        input_file=$one_input
        bookfile="${input_file%.csv}-book.pdf"
    else
        # make sure any new downloads are filed in proper locations
        file_downloads
        input_file=$current_gmail
        bookfile="${input_file%.csv}-book.pdf"
    fi

    for o in $oo
    do
        [[ $o = y* || yes = "$o"* ]] && o=ilamww

        set_opt cur_book_opts "$o" || {
            printf >&2 'Invalid option "%s"\n' "$o"
            continue 2
        }
    done

    declare >&2 -p book_opts cur_book_opts

    desc=( "${cur_book_opts[@]#--book-}" )
    desc=( "${desc[@]/?(ndex|isting)?(-by)-/x\/}" )
    printf >&2 'Book [%s] ...\n' "${desc[*]}"

    time ${libdir}csvdump --preset=book --skip-suppressed-listing "$input_file" "${cur_book_opts[@]}" --force-overwrite --output="$bookfile" &&
    { evince "$bookfile" <>/dev/null >&0 2>&0 3>&- 4>&- 5>&- 6>&- & }

    ((once)) && break
done
