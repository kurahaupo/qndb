#!/usr/bin/perl

use 5.010;
use strict;
use warnings;
use utf8;

use FindBin;
use lib "$FindBin::Bin", "$FindBin::Bin/../lib";

use Fcntl qw( SEEK_SET );
use POSIX qw(strftime);
use Data::Dumper;

use PDF::API2;
use Text::CSV;
use Getopt::Long qw( :config auto_abbrev bundling );

use Carp 'croak', 'carp';

use string_with_components;

use constant now => [ localtime $^T ];
use constant this_year => strftime "%Y", localtime $^T;
use constant this_date => strftime "%Y%m%d", localtime $^T;
use constant sixteen_this_date => strftime "%Y%m%d", localtime $^T - 504921600;

use constant CHECK_ARGS => 1;

use verbose;

################################################################################

use list_functions;

sub sort_by_surname(@) {
    if ( my @x = grep { ! defined $_->{composite_name} } @_ ) { ::croak "Records don't have names:\n" . Dumper(\@x) }
    if ( my @x = grep { ! defined $_->{composite_name}->{sort_by_surname} } @_ ) { die "Records have names without sort-by-surname:\n" . Dumper(\@x) }
    return sort { $a->{composite_name}->{sort_by_surname}   cmp $b->{composite_name}->{sort_by_surname}
               || $a->{composite_name}->{sort_by_givenname} cmp $b->{composite_name}->{sort_by_givenname} } @_
}
sub sort_by_givenname(@) {
    if ( my @x = grep { ! defined $_->{composite_name} } @_ ) { ::croak "Records don't have names:\n" . Dumper(\@x) }
    if ( my @x = grep { ! defined $_->{composite_name}->{sort_by_givenname} } @_ ) { die "Records have names without sort-by-givenname:\n" . Dumper(\@x) }
    return sort { $a->{composite_name}->{sort_by_givenname} cmp $b->{composite_name}->{sort_by_givenname}
               || $a->{composite_name}->{sort_by_surname}   cmp $b->{composite_name}->{sort_by_surname} } @_
}
sub preferred_sort(@) {
    goto &sort_by_givenname;
}

use PDF::scale_factors;

################################################################################
#
# Manage the PDF pagination separately from the list-rendering
#
# (the text cursor is per-page, so make sure we get a fresh one for each page)
#

{
package PDF_paginator;

use verbose;
use PDF::scale_factors;

sub _unmethod {
    ref $_[0] && UNIVERSAL::isa( $_[0], __PACKAGE__ ) && shift;
}

sub new {
    my $class = shift;
    my $p = bless { @_ }, $class;
    warn "Next Page\n" if $verbose;
    $p->_startpage;
    $p->pdf->preferences(-twocolumnright => 1);
    return $p;
}

sub pdf {
    my $p = shift;
    $p->{pdf} ||= PDF::API2->new(@_)
}

sub _startpage {
    my $p = shift;
    my $pdf = $p->pdf;
    warn "Next Page\n" if $verbose;
    my $page = $p->{page} = $pdf->page(@_);
    $page->mediabox(@{ $p->{page_size} });
    ( undef, undef, $p->{page_width}, $p->{page_height} ) = $page->get_mediabox();
    $p->{page_item_num} = 0;
    if (my $cb = $p->{upon_start_page}) {
        my $pagenum = $pdf->pages || 0;
        if (ref $cb eq 'CODE') {
            $cb->($p, $pagenum);
        } else {
            for my $cc (@$cb) {
                $cc->($p, $pagenum);
            }
        }
    }
}

sub pagenum {
    my $p = shift;
    $p->_startpage if ! $p->{page};
    my $pdf = $p->pdf;
    $pdf->pages || 0;
}

# get the current page (starting a new page if necessary)
sub page {
    my $p = shift;
    $p->_startpage if ! $p->{page};
    $p->{page};
}

# close the current page, so that the next call to "page" will start a new page
sub closepage {
    my $p = shift;
    $p->{page} or return;  # no current page
    if (my $cb = $p->{upon_end_page}) {
        my $pagenum = $p->pdf->pages || 0;
        if (ref $cb eq 'CODE') {
            $cb->($p, $pagenum);
        } else {
            for my $cc (@$cb) {
                $cc->($p, $pagenum);
            }
        }
    }
    delete $p->{text};
    delete $p->{page};
    delete $p->{pagedata};
}

# get the "text" attribute of the current page (starting a new page if necessary)
sub text {
    my $p = shift;
    $p->{text} ||= $p->page->text();
}

sub corefont {
    my $p = shift;
    my $name = shift;
    $p->{fontcache}{$name} ||= $p->pdf->corefont($name);
}

sub pages {
    my $p = shift;
    $p->pdf->pages || 0
}

sub stringify {
    my $p = shift;
    my $pdf = $p->{pdf} or return;
    $p->closepage;
    my $r = $pdf->stringify;
    %$p = ();
    return $r;
}

#sub write_into {
#    my $p = shift;
#    my $filename = shift;
#    my $pdf = $p->{pdf} or return;
#    $p->closepage;
#    my $r = $pdf->saveas($filename);
#    %$p = ();
#    return $r;
#}

sub _qm($) {
    &_unmethod;
    my $v = $_[0];
    state $qm = {
            map { ( eval("\"\\$_\"") => "\\$_" ) }
                qw{ \ " ' 0 a b e f l n o r t u z } # also: \cC \x{} \N{} \Q..\E \L..\E \U..\E
        };
    $v =~ s{[\\\n\t'"]}{$qm->{$&} // sprintf '\\x%.02x', ord($&)}egr;
}

########################################
# Font notes from:
#
#   https://en.wikipedia.org/wiki/Portable_Document_Format#Standard_Type_1_Fonts_.28Standard_14_Fonts.29
#   Standard Type 1 Fonts (Standard 14 Fonts)
#
#   Fourteen typefaces, known as the standard 14 fonts, have a special
#   significance in PDF documents:
#
#       Times (v3) (in regular, italic, bold, and bold italic)
#       Courier (in regular, oblique, bold and bold oblique)
#       Helvetica (v3) (in regular, oblique, bold and bold oblique)
#       Symbol
#       Zapf Dingbats
#
#   These fonts are sometimes called the base fourteen fonts.[57] These fonts,
#   or suitable substitute fonts with the same metrics, must always be
#   available in all PDF readers and so need not be embedded in a PDF.[58] PDF
#   viewers must know about the metrics of these fonts. Other fonts may be
#   substituted if they are not embedded in a PDF.
#
########################################

my @base_fonts = (
    'Helvetica',
    'Times',
    'Courier',
    'Symbol',
    'Zapf Dingbats',
);
#
# These font variant suffixes only apply to Helvetica & Courier; Times has
# Italic rather than Oblique (see above), while Symbol & Zapf Fingbats have no
# variants.
#

my @font_variants = ( '', '-Bold', '-Oblique', '-BoldOblique', );
my %font_variants = (
        Helvetica => [ undef, 'Helvetica-Bold', 'Helvetica-Oblique', 'Helvetica-BoldOblique' ],
        Times     => [ undef, 'Times-Bold',     'Times-Italic',      'Times-BoldItalic'      ],
        Courier   => [ undef, 'Courier-Bold',   'Courier-Oblique',   'Courier-BoldOblique'   ],
    );
sub font_variant($$;$) {
    &_unmethod;
    my ($basefont, $bold, $italic) = @_;
    my $variation = ( ( $bold || 0 ) | ( $italic ? 2 : 0 ) ) & 3;
    my $f = $font_variants{$basefont};
    return $f && $f->[$variation] || $basefont;
}

use constant {
        b_Bold      => 1,
        b_Italic    => 2,
        b_Underline => 4,
        b_scale     => 8,
    };

sub font {
    my $p = shift;
    my $name = shift;
    my $size = shift;
    my $variation = $_[0] || 0;
    if ( @_ >= 2 ) {
        $variation = 0;
        $variation |= b_Bold   if $_[0];
        $variation |= b_Italic if $_[1];
    }
    $p->text->font($p->corefont($name),$size);
}

########################################
#
#** on hijacking the Unicode Variant Selectors **
#
#   To achieve some basic text flow, we
#
#   According to the Unicode Consortium, the 16 codepoints \ufe00..\ufe0f
#   should act as suffixes to amend the glyph of the preceeding codepoint.
#
#   Instead we use them as a bit-mask to set the Bold, Italic and Underline
#   attributes; note that this only applies to the text_flow and text_size
#   methods; the text_at method does not support in-text variant selection.
#
#   Having used 8 of the 16 codes, we currently we have 1 spare bit.
#
#   In the future this might change, and they'll just code directly for the 14
#   base fonts, with underline encoded elsewhere.
#
#   Or we could instead pick a random high private-use range such as
#   \ue0000..\ue001f
#
########################################

use constant {
        b_ord       => 0xfe00,
    };

use constant {
        TN   => pack('U', b_ord),
        TB   => pack('U', b_ord | b_Bold),
        TI   => pack('U', b_ord | b_Italic),
        TBI  => pack('U', b_ord | b_Bold | b_Italic),
        TU   => pack('U', b_ord | b_Underline),
        TBU  => pack('U', b_ord | b_Bold | b_Underline),
        TIU  => pack('U', b_ord | b_Italic | b_Underline),
        TBIU => pack('U', b_ord | b_Bold | b_Italic | b_Underline),
    };

use constant {
        TIB  => TBI,
        TBUI => TBIU,
        TIBU => TBIU,
        TIUB => TBIU,
        TUBI => TBIU,
        TUIB => TBIU,
        TUB  => TBU,
        TUI  => TIU,
    };

our $TRE = qr/[\x{fe00}-\x{fe0f}]/;

#   use constant TN     => "\x{fe00}";
#   use constant TB     => "\x{fe01}";
#   use constant TI     => "\x{fe02}";
#   use constant TBI    => "\x{fe03}"; use constant TIB => TBI;
#   use constant TU     => "\x{fe04}";
#   use constant TBU    => "\x{fe05}"; use constant TUB => TBU;
#   use constant TIU    => "\x{fe06}"; use constant TUI => TIU;
#   use constant TBIU   => "\x{fe07}"; use constant { TBUI => TBIU, TIBU => TBIU, TIUB => TBIU, TUBI => TBIU, TUIB => TBIU };

#
# Assuming no height bound, how much space would a given chunk of text take,
# if it were given to text_flow (below)?
#

sub text_size($$$$$;$) {
    my ($pq, $fontname, $fontsize, $line_spacing, $str, $width_limit, $col, $v_off) = @_;
    my $lineheight = $fontsize*$line_spacing;
    $str or do {
        warn sprintf "TEXTSIZE text=[%s] font=%.2fmm -> size=(↔%.2fmm,↕%.2fmm) (1 empty line)\n",
                    _qm $str, $fontsize/mm,
                    0, $lineheight/mm,
            if $verbose > 3;
        return 0, $lineheight, 0, 0;
    };
    flush STDERR;
    my $fontstyle = 0;
    my $text = $pq->text;
    my $lines = 1;
    my $width = 0;
    $col //= 0;
    $v_off //= 0;
    $pq->font( $fontname.$font_variants[$fontstyle], $fontsize );
    PART: for ( my @parts = split /(\n|$TRE)/, $str ; @parts ;) {
        my $part = shift @parts;
        $part eq '' and next PART;
        if ( $part eq "\n" ) {
            warn sprintf "TEXTSIZE newline ending line %u at column %.2fmm\n", $lines, $col/mm if $verbose > 3;
            $width >= $col or $width = $col;
            ++$lines;
            $col = 0;
            next PART;
        }
        if ( $part =~ /^$TRE$/ ) {
            $fontstyle = (ord($part) - b_ord) % @font_variants;
            $pq->font( $fontname.$font_variants[$fontstyle], $fontsize );
            warn sprintf "TEXTSIZE fontstyle %x=%s [%s]\n", $fontstyle, join('-', unpack 'b4', $fontstyle), $fontname.$font_variants[$fontstyle] if $verbose > 3;
            next PART;
        }
        my $part_width = $text->advancewidth($part);
        if ($width_limit) {
            my $t = $part;
            warn sprintf "TEXTSIZE linewrap text=[%s] ↔%.2f/%.2fmm\n", _qm($t), $part_width/mm, ($width_limit-$col)/mm,
                if $verbose > 3 && $part_width > $width_limit-$col;
            while ( $part_width > $width_limit-$col ) {
                $t =~ s#[\N{ZWNJ} ]+[^\N{ZWNJ} ]*$## or $col == 0 ? $t =~ s#.$## : ($t = '') or last;
                $part_width = $text->advancewidth($t);
            }
            if ($t ne '' || $col > 0) {
                (my $u = substr($part, length($t))) =~ s#^[\N{ZWNJ} ]+##;
                $t =~ s#\N{NBSP}# #g;
                warn sprintf "TEXTSIZE wrapdone text=[%s]+[%s] ↔%.2f/%.2fmm\n", _qm($t), _qm($u), $part_width/mm, ($width_limit-$col)/mm,
                    if $verbose > 3 && $u ne '';
                unshift @parts, "\n", "  $u" if $u ne ''; # or @parts && $parts[0] ne "\n";
                $part = $t;
            }
            else {
                warn sprintf "TEXTSIZE cantwrap text=[%s] col=%.2fmm\n", $t, $col/mm if $verbose > 3;
            }
        }
        $col += $part_width;
    }
    $width >= $col or $width = $col;
    my $height = $lines * $lineheight + $v_off;
    warn sprintf "TEXTSIZE text=[%s] font=%.2fmm -> size=(↔%.2fmm,↕%.2fmm) (%u lines) return=(↔%.2fmm,↕%.2fmm)\n",
            _qm $str, $fontsize/mm,
            $width/mm, $lines * $lineheight/mm, $lines,
            $col/mm, ($height - $lineheight)/mm,
        if $verbose > 3;
    return $width, $height, $col, $height - $lineheight;
}

#
# Flow lines of text into a box; returns the width & height (same as text_size)
#

sub text_flow($$$$$$$$;$) {
    my ($pq, $fontname, $fontsize, $line_spacing, $str, $width_limit, $top, $left, $col, $v_off) = @_;
    $#_ == 7 or ::croak "text_flow: wrong number of args";
    my $lineheight = $fontsize*$line_spacing;
    $str or do {
        warn sprintf "TEXTFLOW text=[%s] font=%.2fmm -> size=(↔%.2fmm,↕%.2fmm) (1 empty line)\n",
                    _qm $str, $fontsize/mm,
                    0, $lineheight/mm,
            if $verbose > 3;
        return 0, $lineheight;
    };
    flush STDERR;
    my $fontstyle = 0;
    my $underline = 0;
    my $text = $pq->text;
    my $lines = 1;
    my $ypos = $top - $lineheight;
    my $width = 0;
    $col //= 0;
    $pq->font( $fontname.$font_variants[$fontstyle], $fontsize );
    warn sprintf "TEXTFLOW position  →%.2fmm,↑%.2fmm\n",
            $left/mm, $ypos/mm,
        if $verbose > 3;
    $text->translate( $left, $ypos );

    PART: for ( my @parts = split /(\n|$TRE)/, $str ; @parts ;) {
        my $part = shift @parts;
        $part eq '' and next PART;
        if ( $part eq "\n" ) {
            warn sprintf "TEXTFLOW newline ending line %u at column %.2fmm\n", $lines, $col/mm if $verbose > 3;
            $width >= $col or $width = $col;
            ++$lines;
            $ypos -= $lineheight;
            $col = 0;
            warn sprintf "TEXTFLOW position →%.2fmm,↑%.2fmm\n",
                    $left/mm, ($ypos)/mm,
                if $verbose > 3;
            $text->translate( $left, $ypos );
            next PART;
        }
        if ( $part =~ /^$TRE$/ ) {
            $fontstyle = (ord($part) - b_ord);
            $underline = $fontstyle & b_Underline;
            $fontstyle %= @font_variants;
            my $xfontname = $fontname.$font_variants[$fontstyle];
            $pq->font( $xfontname, $fontsize );
            warn sprintf "TEXTFLOW fontstyle %x=%s [%s]\n", $fontstyle, join('-', unpack 'b4', $fontstyle), $xfontname if $verbose > 3;
            next PART;
        }
        my $part_width = $text->advancewidth($part);
        if ($width_limit) {
            my $t = $part;
            warn sprintf "TEXTFLOW linewrap text=[%s] ↔%.2f/%.2fmm\n", _qm($t), $part_width/mm, ($width_limit-$col)/mm,
                if $verbose > 3 && $part_width > $width_limit-$col;
            while ( $part_width > $width_limit-$col ) {
                $t =~ s#[\N{ZWNJ} ]+[^\N{ZWNJ} ]*$## or $col == 0 ? $t =~ s#.$## : ($t = '') or last;
                $part_width = $text->advancewidth($t);
            }
            if ($t ne '' || $col > 0) {
                (my $u = substr($part, length($t))) =~ s#^[\N{ZWNJ} ]+##;
                $t =~ s#\N{NBSP}# #g;
                warn sprintf "TEXTFLOW wrapdone text=[%s]+[%s] ↔%.2f/%.2fmm\n", _qm($t), _qm($u), $part_width/mm, ($width_limit-$col)/mm,
                    if $verbose > 3 && $u ne '';
                unshift @parts, "\n", "  $u" if $u ne ''; # or @parts && $parts[0] ne "\n";
                $part = $t;
            }
            else {
                warn sprintf "TEXTFLOW cantwrap text=[%s] col=%.2fmm\n", $t, $col/mm if $verbose > 3;
            }
        }
        $text->text($part, $underline ? ( -underline => 'auto' ) : ());
        $col += $part_width;
    }
    $width >= $col or $width = $col;
    warn sprintf "TEXTFLOW text=[%s] font=%.2fmm pos=(→%.2fmm,↑%.2fmm) -> size=(↔%.2fmm,↕%.2fmm) (%u lines) return=(↔%.2fmm,↕%.2fmm)\n",
                _qm $str, $fontsize/mm,
                $left/mm, $top/mm,
                $width/mm, ($ypos - $top)/mm,
                $lines,
                $col/mm, ($lines > 1 && $top - $ypos - $lineheight)/mm,
        if $verbose > 3;
    return $width, $top - $ypos, $col, $lines > 1 && $top - $ypos - $lineheight;
}

#
# $pq->text_at("text", \%opts)
#
# Write a single line of text with full control, including box alignment, orientation, font style
# (attempt to arrange so that the top/left is not overlapped -- hopefully)
#
# + The text to be written must be given
#
# + The font & font-size must be given
#
# + Rotation if given is anticlockwise, and may be given in quadrants (r),
#   degrees (r°) or radians (rr); defaults to 0°.
#
# + X and Y positions must be given, and the text may be aligned below,
#   centred-on or above the y-position, and right-of, centred-on or left-of the
#   x-position. (If the text is not orthogonal, the diagonal points are used.)
#

use math_constants 'PI';
use list_functions qw{ min max sum };

#my @styleopts = qw{ bold italic };
sub text_at($$%) {
    my $pq = shift;
    my $str = shift;
    my $opts = @_ == 1 && ref $_[0] ? shift @_ : { @_ };

    $str =~ /\n|$TRE/ and ::croak "text_at does not support multiline or multifont text";

    defined $str && $str ne '' or do {
        warn sprintf "TEXT_AT (empty)\n" if $verbose > 3;
        return;
    };

    my $xpoint      = $opts->{x}                // ::croak "Missing x";
    my $ypoint      = $opts->{y}                // ::croak "Missing y";
    my $fontname    = $opts->{fontname}         //
                      $opts->{fn}               //
                        ::croak "Missing fontname";
    my $fontsize    = $opts->{fontsize}         //
                      $opts->{fs}               //
                        ::croak "Missing fontsize";
    my $fontstyle   = $opts->{fontstyle}        //
                        ( $opts->{bold} ? 1 : 0 ) | ( $opts->{italic} ? 2 : 0 );
    my $underline   = $opts->{underline} //
                        ($fontstyle >> 2 & 1);
    $fontstyle &= 3;

    my $halign      = $opts->{halign}           // 0;   # default to left (all parts of the text must be right of the specified position)
    my $valign      = $opts->{valign}           // 0;   # default to top (all parts of the text must be below the specified position)

    my $rotation    = $opts->{pi_rotation}      //      # rotation in radians [0..2π]
                      $opts->{rr}               //
                      ( $opts->{quad_rotation}  //      # rotation in quadrants [0..4]
                        $opts->{r}              //
                        ( $opts->{'r°'}         //
                          $opts->{deg_rotation} //      # rotation in degrees [0..360]
                          0                             # default to standard orientation
                        ) / 90                          # convert degrees to quadrants
                      ) / 2 * PI;                       # convert quadrants to radians

    # benchmarking (on an Intel x86_64 T7200) indicates that a ?: is around 5
    # times faster than trig, so this is usually a win
    my $sin = $rotation ? sin($rotation) : 0;
    my $cos = $rotation ? cos($rotation) : 1;

#   flush STDERR;
    $fontstyle //= 0;
    $fontname .= $font_variants[$fontstyle];
    $pq->font( $fontname, $fontsize );

    my $text = $pq->text;
    my $width = $text->advancewidth($str);
    my $height = $fontsize;

    my $bl_x_off = 0;
    my $bl_y_off = 0;
    my $tl_x_off = $height * -$sin;
    my $tl_y_off = $height *  $cos;
    my $br_x_off = $width  *  $cos;
    my $br_y_off = $width  *  $sin;
    my $tr_x_off = $tl_x_off + $br_x_off;
    my $tr_y_off = $tl_y_off + $br_y_off;

    my $l_off = min $bl_x_off, $br_x_off, $tl_x_off, $tr_x_off;
    my $r_off = max $bl_x_off, $br_x_off, $tl_x_off, $tr_x_off;
    my $t_off = max $bl_y_off, $br_y_off, $tl_y_off, $tr_y_off;
    my $b_off = min $bl_y_off, $br_y_off, $tl_y_off, $tr_y_off;

    my $xpos = $xpoint - ( $halign == 0 ? $l_off : $halign == 2 ? $r_off : ($l_off+$r_off)/2 );
    my $ypos = $ypoint - ( $valign == 0 ? $t_off : $valign == 2 ? $b_off : ($t_off+$b_off)/2 );

    warn sprintf "TEXT_AT text=[%s] font=(size=%.2fmm,style=%u) :: refpoint=(→%.2fmm,↑%.2fmm) rotation=%.0f° align=(%s) -> origin=(→%.2fmm,↑%.2fmm) bound=(t=%.2fmm,b=%.2fmm,l=%.2ffm,r=%.2fmm)\n",
                _qm $str,
                $fontsize/mm, $fontstyle,
                $xpoint/mm, $ypoint/mm,
                $rotation / PI * 180,
                [['┌','┬','┐'],
                 ['├','┼','┤'],
                 ['└','┴','┘'],]->[$valign][$halign],   #substr('╔╦╗╠╬╣╚╩╝', $valign*3+$halign, 1),
                $xpos/mm, $ypos/mm,
                $ypoint-$t_off, $ypoint-$b_off,
                $xpoint-$l_off, $xpoint-$r_off,
                ($ypos - $ypoint)/mm,
        if $verbose > 3;

    $text->transform(
        -translate => [$xpos, $ypos],
        -rotate    => $rotation / PI * 180,
      # -scale     => [$sx, $sy],
      # -skew      => [$sa, $sb],
    );

    $text->text($str, $underline ? (-underline => 'auto') : ());

    return ();
}

#sub DESTROY { }
}

use CSV::gmail;
use CSV::qndb;
use CSV::adhoc1;
use CSV::adhoc2;

################################################################################

use phone_functions;

use POSIX 'strftime';

sub show_date($) {
    for ( my $z = shift ) {
    s/T\d\d.*//;
    if (my @ymd = m/^(19\d\d|20[01]\d)\W*([012]\d)\W*(\d\d)$/) {
        warn "Date '$_' with year, ymd=[@ymd]" if $verbose > 3;
        if ($ymd[0] >= 1900 && $ymd[0] <= this_year && $ymd[1] <= 12 && $ymd[2] <= 31) {
            $_ = (strftime "%d %b %Y", 0,0,0,$ymd[2],$ymd[1]-1,$ymd[0]-1900,0,0)." ($_) (ymd)";
        }
    }
    elsif (my @dmy = m/^(\d\d)([012]\d)(19\d\d|20[01]\d)$/) {
        warn "Date '$_' with year, dmy=[@dmy]" if $verbose > 3;
        if ($dmy[2] >= 1900 && $dmy[2] <= this_year && $dmy[1] <= 12 && $dmy[0] <= 31) {
            $_ = (strftime "%d %b %Y", 0,0,0,$dmy[0],$dmy[1]-1,$dmy[2]-1900,0,0)." ($_) (dmy)";
        }
    }
    elsif (my @md = m/^\s*\-\-([012]\d)\-(\d\d)$/) {
        warn "Date '$_' without year, md=[@md]" if $verbose > 3;
        # day & month without year (GMail-style)
        if ($md[0] <= 12 && $md[1] <= 31) {
            $_ = (strftime "%d %b", 0,0,0,$md[1],$md[0]-1,-120,0,0)." ($_) (xmd)";
        }
    }
#   elsif ( m/./ ) {
#       warn "Date '$_' could not be matched" if $verbose > 2;
#   }
    warn "FIXED date $_" if $verbose > 3;
    return $_;
    }
}

sub show_qonu($) { $_[0] =~ /^GEN/ and return ''; return sprintf "http://quaker.org.nz/user/%s/edit/profile", shift }

my %show_fields = (
    birthdate                   => \&show_date,   # CSV::qndb
  # uid                         => \&show_qonu,   # CSV::qndb
  # uid_of_children_under_16    => \&show_qonu,   # CSV::qndb
  # uid_of_spouse               => \&show_qonu,   # CSV::qndb
  # uids_of_parents             => \&show_qonu,   # CSV::qndb
);

########################################

my $paper_sizes = {
        # A-series paper sizes, portrait
        (map {
            (my $x = $_) =~ s/^a//i;
            my $h = 2**(0.25-$x/2);
            my $w = $h / sqrt(2);
            ( ( $_ < 0 ? (2**-$_).'a0' : "a$_") => [ $h*1000*mm, $w*1000*mm ] );
        } -2 .. 10),
        # B-series paper sizes, portrait
        (map {
            (my $x = $_) =~ s/^b//i;
            my $h = 2**(0.5-$x/2);
            my $w = $h / sqrt(2);
            ( ( $_ < 0 ? (2**-$_).'b0' : "b$_") => [ $h*1000*mm, $w*1000*mm ] );
        } 0 .. 10),
        # C-series envelope sizes, landscape
        (map {
            (my $x = $_) =~ s/^c//i;
            my $w = 2**(0.375-$x/2);
            my $h = $w / sqrt(2);
            ( ( $_ < 0 ? (2**-$_).'c0' : "c$_") => [ $h*1000*mm, $w*1000*mm ] );
        } 0 .. 10),
        # DL envelope size, landscape
        dl => [ 110*mm, 220*mm ],
    };

########################################
# actual parsing of command-line

sub II(&) {
    my $f = pop;
    sub {
        for my $i ( split m{\s*,\s*}, $_[1] ) {
            my @k = split m{[=/]}, $i;
            $k[1] ||= '!post '.$k[0];
            $f->(@k);
        }
    }
}

sub as_points($) {
    my $v = $_[0];
    if ($v =~ s/[a-z]+$//) {
        state $units = {
            cm => 0.1*mm,
            in => in,
            m  => 1000*mm,
            mm => mm,
            pt => pt,
            px => px,
            μm => 0.001*mm,
        };
        $v *= $units->{$&} || die "Unknown unit-of-measure $&\n";
    }
    $v;
}

################################################################################
#
# Process command-line options
#

use math_constants 'PHI';   # used in several default calculations...

########################################
# Decoding & parsing input files

my $csv_fs_char;
my $csv_quote_char;
my $csv_escape_char;
my $force_decoding;
my $presume_decoding;
my $use_encoding;

if (my $lang = $ENV{LANG}) {
    $presume_decoding =
    $use_encoding = 'UTF-8' if $lang =~ /\.UTF-8$/;
}

########################################
# How are records selected (these affect various modes in DWIM ways...)

my $need_region = 1;
my $skip_archived = 1;
my $skip_deceased = 1;
my $skip_meetings = 1;
my $skip_newsletters_only = undef;      # default to "yes" for do_book
my $skip_suppressed_listing = undef;    # default to "yes" for do_book
my $skip_suppressed_email = 0;
my $skip_suppressed_post = undef;       # default to "yes" for do_labels
my $skip_unsub = 1;
my @inclusion_labels;
my @inclusion_tags;
my @restrict_regions;
my @selection_tags;

########################################
# Output selections

my $do_test = 0;
my $do_book = 0;
my $do_book_index_all;
my $do_book_index_by_mm;
my $do_book_index_by_wg;
my $do_book_listing_all;
my $do_book_listing_by_mm;
my $do_book_listing_by_wg;
my $do_diff = 0;
my $do_diffable_dump = 0;
my $do_labels = 0;
my $do_qndb_map = 0;
my $book_phones_first = 1;

my $output_name;
my $force_overwrite;

########################################
# Dump formatting options

my $names_only = 0;
my $output_bom = 0;
my $output_crlf;
my $show_relationships = 1;
my $show_uid;
my $suppress_adult_birthdays = 1;
my $suppress_send_by_post = 0;
my $suppress_send_by_email = 1;
my $suppress_status = 0;
my $suppress_yf_listing = 0;
my $show_hyperlinks = 1;
my $diff_by = 'uid';
my $diff_ignore_file;
my $diff_quietly = 0;

########################################
# Generic PDF output options (shared between labels and book generation)

my $page_size          ; # = 'a4';
my $page_height        ; # = 297.302*mm;
my $page_width         ; # = 210.224*mm;

my $page_left_margin   ; # = 18*mm;
my $page_right_margin  ; # = 18*mm;
my $page_bottom_margin ; # = 14*mm;
my $page_top_margin    ; # = 14*mm;

my $line_spacing = 1.25;    # ratio of font-size to line-pitch

my $extra_para_spacing = 0.25;  # used between records in book format

########################################
# Book formatting options

my $book_intercolumn_margin; #  = 10*mm;
my $book_interdetail_spacing = 1.75*mm;

my $book_sort_by_givenname;  # } will output BOTH lists if both these are selected
my $book_sort_by_surname;    # }

my $book_fontname  = 'Helvetica';
my $book_email_fontname  = 'Courier';
my $book_fontsize = 8.5*pt;     # depends on page size scaling
my $book_pagenumber_fontsize = $book_fontsize / PHI;
my $book_margin_fontsize = $book_fontsize * PHI;
my $use_page_numbers;

########################################
# Label formatting options

my $show_tiny_labels = 1;
my $use_cropbox = 0;
my $evenly_squash_to_fit = 0;

my $label_left_margin = 1*mm;
my $label_right_margin = 1*mm;
my $label_bottom_margin = 4*mm;
my $label_top_margin = 4*mm;

my $label_fontname = 'Helvetica';
my $label_fontsize = 12*pt;
my $label_postcode_fontsize = 14*pt;

my $label_banner_font = 'Helvetica';
my $label_banner_scale = PHI;
my $label_banner_colour = 'orange';

my $label_width;
my $label_height;
my $label_step_across;
my $label_step_down;
my $num_labels_across = 2;
my $num_labels_down = 4;
my $labels_ordered_in = 'columns';

########################################

    sub use_preset {
        my $pt = pop;

        state $x = warn Dumper($paper_sizes) if $verbose > 4 && $debug;

        state $label_product = {
            ( map { ( $_     => { page_size => $_,     page_height => $paper_sizes->{$_}->[0], page_width => $paper_sizes->{$_}->[1], num_labels_across => 2, num_labels_down => 3, } ) } keys %$paper_sizes ),
            ( map { ( $_.'R' => { page_size => $_.'R', page_height => $paper_sizes->{$_}->[1], page_width => $paper_sizes->{$_}->[0], num_labels_across => 3, num_labels_down => 2, } ) } keys %$paper_sizes ),

            'avery-l7160' => {
                    page_size            => 'a4',
                    page_height          => 297.302*mm,
                    page_width           => 210.224*mm,
                    num_across           => 3,
                    num_down             => 7,
                    page_top_margin      => 17.0*mm, label_top_margin     =>  1.5*mm,
                    page_bottom_margin   => 13.0*mm, label_bottom_margin  =>  1.5*mm,
                    page_left_margin     =>  5.0*mm, label_left_margin    =>  5.7*mm,
                    page_right_margin    =>  6.0*mm, label_right_margin   =>  7.7*mm,
                    ordered_in           => 'columns',
                },

            'book' => {
                    page_size          => 'a5',
                    page_height        => 210.224*mm,
                    page_width         => 148.651*mm,

                    page_left_margin   => 13*mm,
                    page_right_margin  => 13*mm,
                    page_bottom_margin => 10*mm,
                    page_top_margin    => 10*mm,
                    book_intercolumn_margin => 7*mm,
                },
            };

        state $y = warn Dumper($label_product) if $verbose > 4 && $debug;

        my $p = $label_product->{$pt} || die "Unknown label or paper product '$pt'\nAvailable presets are @{[sort keys %$label_product]}\n";
        (
            $page_size, $page_height, $page_width,
            $num_labels_across, $num_labels_down, $labels_ordered_in,
            $page_top_margin, $page_bottom_margin, $page_left_margin, $page_right_margin,
            $label_top_margin, $label_bottom_margin, $label_left_margin, $label_right_margin,
            $book_intercolumn_margin,
        ) = @$p{qw{
            page_size page_height page_width
            num_across num_down ordered_in
            page_top_margin page_bottom_margin page_left_margin page_right_margin
            label_top_margin label_bottom_margin label_left_margin label_right_margin
            book_intercolumn_margin
        }};
    }

my @ORIG_ARGV = @ARGV;

sub M($) { my $r = \$_[0]; sub { $$r = as_points $_[-1] } }
sub N($) { my $r = \$_[0]; sub { $$r = ! $_[1] } }
GetOptions

    'A=i'                         => sub { $page_size = $_[0].$_[1]; $page_width = $page_height = undef },  #A4 etc
    'B=i'                         => sub { $page_size = $_[0].$_[1]; $page_width = $page_height = undef },  #B4 etc
    'all-regions|any-region'      => sub { @restrict_regions = () },
    'book-index-all'              => \$do_book_index_all,
    'book-index-by-mm'            => \$do_book_index_by_mm,
    'book-index-by-wg'            => \$do_book_index_by_wg,
    'book-listing-all'            => \$do_book_listing_all,
    'book-listing-by-mm'          => \$do_book_listing_by_mm,
    'book-listing-by-wg'          => \$do_book_listing_by_wg,
    'book-names-first'            => N$book_phones_first,
    'book-phones-first'           => \$book_phones_first,
    'canonical-addresses!'        => \$CSV::Common::canon_address,
    'care-of!'                    => \$CSV::Common::use_care_of,
    'explicitly-shared!'          => \$CSV::Common::only_explicitly_shared_email,
    'csv'                         => sub { $csv_fs_char = ',' },
    'debug|x'                     => sub { set_verbose 'debug='.$_[-1] },
    'decode-octet|decode-byte|db' => sub { $presume_decoding = 'OCTET' },
    'decode-utf16be|du16b'        => sub { $presume_decoding = 'UTF-16BE' },
    'decode-utf16le|du16l'        => sub { $presume_decoding = 'UTF-16LE' },
    'decode-utf8|du8'             => sub { $presume_decoding = 'UTF-8' },
    'decoding=s'                  =>      \$presume_decoding,
    'diff'                        => \$do_diff,
    'diff-quietly'                => \$diff_quietly,
    'diff-by-any'                 => sub { $diff_by = '' },
    'diff-by-name'                => sub { $diff_by = 'name' },
    'diff-by-uid'                 => sub { $diff_by = 'uid' },
    'diff-ignore-file=s'          => \$diff_ignore_file,
    'dump|diffable-dump'          => \$do_diffable_dump,
    'encode-octet|encode-byte|eb' => sub { $use_encoding = 'OCTET' },
    'encode-utf16be|eu16b'        => sub { $use_encoding = 'UTF-16BE' },
    'encode-utf16le|eu16l'        => sub { $use_encoding = 'UTF-16LE' },
    'encode-utf8|eu8'             => sub { $use_encoding = 'UTF-8' },
    'encoding=s'                  =>      \$use_encoding,
    'escape-char=s'               => \$csv_escape_char,
    'force-decode-octet|force-decode-byte|fdb' => sub { $force_decoding = 'OCTET' },
    'force-decode-utf16be|fdu16b' => sub { $force_decoding = 'UTF-16BE' },
    'force-decode-utf16le|fdu16l' => sub { $force_decoding = 'UTF-16LE' },
    'force-decode-utf8|fdu8'      => sub { $force_decoding = 'UTF-8' },
    'force-decoding=s'            =>      \$force_decoding,
    'force-overwrite|f!'          => \$force_overwrite,
    'fs-char|sep-char=s'          => \$csv_fs_char,
    'hide-adult-birthdays!'       => \$suppress_adult_birthdays,
    'hide-hyperlinks!'            => N$show_hyperlinks,
    'hide-no-region!'             => \$need_region,
    'hide-relationships!'         => N$show_relationships,
    'hide-send!'                  => sub { $suppress_send_by_email = $suppress_send_by_post = $_[-1] },
    'hide-send-by-email!'         => \$suppress_send_by_email,
    'hide-send-by-post!'          => \$suppress_send_by_post,
    'hide-status!'                => \$suppress_status,
    'hide-uid!'                   => N$show_uid,
    'hide-yf-listing!'            => \$suppress_yf_listing,
    'include-archived!'           => N$skip_archived,
    'include-deceased!'           => N$skip_deceased,
    'include-meetings!'           => N$skip_meetings,
    'include-newsletters-only!'   => N$skip_newsletters_only,
    'include-no-region!'          => N$need_region,
    'include-suppressed-email!'   => N$skip_suppressed_email,
    'include-suppressed-listing!' => N$skip_suppressed_listing,
    'include-suppressed-post!'    => N$skip_suppressed_post,
    'include-unsubscribed'        => N$skip_unsub,
    'instruction-color|instruction-colour=s' => \$label_banner_colour,
    'label-height|lh=s'           => M$label_height,
    'label-step-across|lxw=s'     => M$label_step_across,
    'label-step-down|lxh=s'       => M$label_step_down,
    'label-width|lw=s'            => M$label_width,
    'labels'                      => \$do_labels,
    'labels-ordered-in-columns'   => sub { $labels_ordered_in = 'columns' },
    'labels-ordered-in-rows'      => sub { $labels_ordered_in = 'rows' },
    'labels-ordered-in=s'         => \$labels_ordered_in,
    'names-only!'                 => \$names_only,
    'need-region!'                => \$need_region,
    'num-labels-across|nla=i'     => \$num_labels_across,
    'num-labels-down|nld=i'       => \$num_labels_down,
    'octet|byte|b'                => sub { $presume_decoding = $use_encoding = 'OCTET' },
    'optional-include=s'          => II {                              push @inclusion_labels, $_[0]; push @inclusion_tags, $_[1]; },
    'output-bom|bom!'             => \$output_bom,
    'output-crlf|crlf!'           => \$output_crlf,
    'output|o=s'                  => \$output_name,
    'page-height|ph=s'            => sub { $page_size = undef; $page_height = as_points pop },
    'page-numbering!'             => \$use_page_numbers,
    'page-size=s'                 => sub { $page_size = pop; $page_width = $page_height = undef },  #A4, B3, etc
    'page-width|pw=s'             => sub { $page_size = undef; $page_width  = as_points pop },
    'preset=s'                    => \&use_preset,
    'qndb-map'                    => \$do_qndb_map,
    'quiet|q'                     => sub { set_verbose 0 },
    'quote-char=s'                => \$csv_quote_char,
    'raw-addresses!'              => N$CSV::Common::canon_address,
    'region|only-region=s'        => sub { push @restrict_regions, split /[, ]+/, pop },
    'select-and-include=s'        => II { push @selection_tags, $_[1]; push @inclusion_labels, $_[0]; push @inclusion_tags, $_[1]; },
    'select=s'                    => II { push @selection_tags, $_[1]; },
    'show-adult-birthdays!'       => N$suppress_adult_birthdays,
    'show-hyperlinks!'            => \$show_hyperlinks,
    'show-relationships!'         => \$show_relationships,
    'show-send!'                  => sub { $suppress_send_by_email = $suppress_send_by_post = ! $_[-1] },
    'show-send-by-email!'         => N$suppress_send_by_email,
    'show-send-by-post!'          => N$suppress_send_by_post,
    'show-status!'                => N$suppress_status,
    'show-uid!'                   => \$show_uid,
    'show-yf-listing!'            => N$suppress_yf_listing,
    'skip-archived!'              => \$skip_archived,
    'skip-deceased!'              => \$skip_deceased,
    'skip-meetings!'              => \$skip_meetings,
    'skip-newsletters-only!'      => \$skip_newsletters_only,
    'skip-suppressed-email!'      => \$skip_suppressed_email,
    'skip-suppressed-listing!'    => \$skip_suppressed_listing,
    'skip-suppressed-post!'       => \$skip_suppressed_post,
    'skip-unsubscribed'           => \$skip_unsub,
    'sort-book-by-givenname'      => \$book_sort_by_givenname,
    'sort-book-by-surname'        => \$book_sort_by_surname,
    'test'                        => \$do_test,
    'tsv'                         => sub { $csv_fs_char = "\t"; $csv_escape_char = $csv_quote_char = ""; },
    'utf16be|u16b'                => sub { $presume_decoding = $use_encoding = 'UTF-16BE' },
    'utf16le|u16l'                => sub { $presume_decoding = $use_encoding = 'UTF-16LE' },
    'utf8|u8'                     => sub { $presume_decoding = $use_encoding = 'UTF-8' },
    'v+'                          => \&set_verbose,
    'verbose=s'                   => \&set_verbose,
    'why-not|why-skipped'         => sub { set_verbose 'why='.$_[-1] },

    'help|h'                      => sub { print <<EndOfHelp ; exit 0 },
$0 --book-{index|listing}-{all|by-{mm|wg}} [book-options|pdf-output-options|generic-options]...
$0 --labels [label-options|pdf-output-options|generic-options]...
$0 --diff [diff-options|dump-options|text-output-options|generic-options]...
$0 --dump [dump-options|text-output-options|generic-options]...
$0 --qndb-map [qndb-map-options|text-output-options|generic-options]...

For additional options see:
    $0 --help-book
    $0 --help-diff
    $0 --help-dump
    $0 --help-labels
    $0 --help-qndb

    $0 --help-generic

    $0 --help-input
    $0 --help-selection
    $0 --help-tuning

    $0 --help-output
    $0 --help-pdf
EndOfHelp

    'help-diff'                   => sub { print <<EndOfHelp; exit 0 },
diff-options:
    --names-only
    --names-only
    --diff-quietly
    --diff-by-any
    --diff-by-name
    --diff-by-uid
    (plus dump-options)

See:
    $0 --help-dump
    $0 --help-output
    $0 --help-generic
EndOfHelp

    'help-dump'                   => sub { print <<EndOfHelp; exit 0 },
dump-options:
    --[no-]names-only
    --[no-]{show|hide}-adult-birthdays
    --[no-]{show|hide}-hyperlinks
    --[no-]{show|hide}-relationships
    --[no-]{show|hide}-send
    --[no-]{show|hide}-send-by-email
    --[no-]{show|hide}-send-by-post
    --[no-]{show|hide}-uid
    --[no-]{show|hide}-status
    --[no-]{show|hide}-yf-listing
    (plus text-output-options)

See also:
    $0 --help-output
    $0 --help-generic
EndOfHelp

    'help-qndb'                   => sub { print <<EndOfHelp; exit 0 },
qndb-map-options (with --qndb-map):
    (none yet)
    (plus text-output-options)

See:
    $0 --help-output
    $0 --help-generic
EndOfHelp

    'help-book'                   => sub { print <<EndOfHelp; exit 0 },
book-options:
    --book-index-all
    --book-index-by-mm
    --book-index-by-wg
    --book-listing-all
    --book-listing-by-mm
    --book-listing-by-wg
    --book-names-first          tabulate main list as: name, phone, address
    --book-phones-first         tabulate main list as: phone, name, address
    --sort-book-by-{surname|givenname}  NB: will output BOTH lists if both these are selected
    (plus pdf-output-options)

See:
    $0 --help-pdf
    $0 --help-generic
EndOfHelp

    'help-labels'                 => sub { print <<EndOfHelp; exit 0 },
label-options (with --labels):
    --preset={avery-l7160|...}
    --instruction-colour=COLOUR     colour of metadata labels
    --label-height=LENGTH       --lh=LENGTH
    --label-step-across=LENGTH  --lxw=LENGTH
    --label-step-down=LENGTH    --lxh=LENGTH
    --label-width=LENGTH        --lw=LENGTH
    --labels-ordered-in={columns|rows}
    --labels-ordered-in-{columns|rows}
    --num-labels-across=NUM     --nla=NUM
    --num-labels-down=NUM       --nld=NUM
    (plus pdf-output-options)

See:
    $0 --help-pdf
    $0 --help-generic
EndOfHelp

    'help-pdf'                    => sub { print <<EndOfHelp; exit 0 },
pdf-output-options
    --page-size={A0,A1,...,B0,B1,...}
    -A{0...9}  -B{0...9}                ISO paper sizes
    --page-height=LENGTH  --ph=LENGTH
    --page-width=LENGTH  --pw=LENGTH
EndOfHelp

    'help-output'                 => sub { print <<EndOfHelp; exit 0 },
text-output-options:
    --[no-]output-bom       --[no-]bom
    --[no-]output-crlf      --[no-]crlf
    --encoding={OCTET|UTF-{8|16|16LE|16BE|32|32LE|32BE}}
        --encode-octet --encode-byte    --eb        (--encoding=OCTET)
        --encode-utf16be                --eu16b     (--encoding=UTF-16BE)
        --encode-utf16le                --eu16l     (--encoding=UTF-16LE)
        --encode-utf8                   --eu8       (--encoding=UTF-8)
    --output=FILENAME -oFILENAME

  * conjoint input & output text options
        --octet  --byte  -b                         (--decoding=OCTET    --encoding=OCTET)
        --utf8  --u8                                (--decoding=UTF-8    --encoding=UTF-8)
        --utf16be  --u16b                           (--decoding=UTF-16BE --encoding=UTF-16BE)
        --utf16le  --u16l                           (--decoding=UTF-16LE --encoding=UTF-16LE)
EndOfHelp

    'help-generic'                => sub { print <<EndOfHelp; exit 0 },
generic-options:
    -v[v...] | --verbose | -q | --quiet
    -x | --debug                    enable debugging output
    --[no-]force-overwrite -f       clobber preexisting output files
    (plus input-options)
    (plus record-selection-options)
    (plus record-tuning-options)

See also:
    $0 --help-input
    $0 --help-selection
    $0 --help-tuning
EndOfHelp

    'help-input'                  => sub { print <<EndOfHelp; exit 0 },
 input-options:
    --decoding                  assume input encoding if it cannot be deduced
    --force-decoding            assume input encoding overriding any deduction
    --decoding={OCTET|UTF-{8|16|16LE|16BE|32|32LE|32BE}}
        --decode-octet --decode-byte    --db (--decode-octet)
        --decode-utf16be                --du16b (--decode-utf16be)
        --decode-utf16le                --du16l (--decode-utf16le)
        --decode-utf8                   --du8 (--decode-utf-8)
    --csv                       assume input is comma-separated
    --tsv                       assume input is tab-separated
    --fs-char=CHAR --sep-char=CHAR  field separating character
    --quote-char=CHAR               quote character
    --escape-char=CHAR              escape character
EndOfHelp

    'help-selection'              => sub { print <<EndOfHelp; exit 0 },
 record-selection-options:
    --[only-]region=REGION[,REGION...]          exclude records not in any of the REGIONs
    --all-regions           --any-region        include records with any region
    --no-need-region --no-hide-no-region     --include-no-region include records without a region
       --need-region    --hide-no-region  --no-include-no-region exclude records without a region
    --[no-]include-archived --[no-]skip-archived
    --include-deceased      --skip-deceased
    --include-meetings      --skip-meetings
    --include-unsubscribed  --skip-unsubscribed
    --only-region=REGION
    --select-and-include=TAG[,TAG...]
    --select=TAG[,TAG...]
    --optional-include=TAG[,TAG...]
    --why-not  --why-skipped        [explain exclusion of each record]
EndOfHelp

    'help-tuning'                 => sub { print <<EndOfHelp; exit 0 },
 record-tuning-options:
       --canonical-addresses --no-raw-addresses     convert address elements to canonical abbreviations (e.g. Street -> St)
    --no-canonical-addresses    --raw-addresses     don't convert address elements to canonical abbreviations (e.g. Street -> St)
       --care-of                                    include 'c/-' where it would be inferred from the "type" field
    --no-care-of                                    omit 'c/-' where it would be inferred from the "type" field
EndOfHelp

    or exit 64;

$verbose and *STDOUT{IO}->autoflush(1);
$verbose and *STDERR{IO}->autoflush(1);

$verbose and warn sprintf "RUN: %s\n", join ' ', map { ! m{[^0-9A-Za-z!#%+,-./:=@^_~]|^\#} ? $_ : ! m/['\\]/ ? "'$_'" : ! m/["\\\$]/ ? '"'.$_.'"' : s{[^0-9A-Za-z!#%+,-./:=@^_~]}{\\$&}gr } $0, @ORIG_ARGV;

########################################
#
# Compute some derivative fallback values for parameters that can also be set
# on commandline
#

use quaker_info '%mm_names';

$_ = uc $_ for @restrict_regions;
@restrict_regions = grep { $_ ne 'NONE' or $need_region = 0; } @restrict_regions;

$mm_names{$_} or die "Invalid region '$_'\n" for @restrict_regions;

warn "RESTRICTION: limit to regions: @restrict_regions\n" if $verbose > 2;

$do_book ||= $do_book_index_by_wg || $do_book_index_by_mm || $do_book_index_all || $do_book_listing_by_wg || $do_book_listing_by_mm || $do_book_listing_all;

# Default exclusions for different generation types
$skip_suppressed_listing //= $do_book;
$skip_newsletters_only   //= $do_book;
$skip_suppressed_post    //= $do_labels;

my @wr_binmode;
my @wr_bom;
if ( $use_encoding && $use_encoding ne 'OCTET' ) {
    @wr_binmode = ":encoding($use_encoding)";
    @wr_bom = "\x{feff}" if $output_bom;
    binmode STDERR, "@wr_binmode";
}
$output_crlf and push @wr_binmode, ":crlf";
unshift @wr_binmode, ":raw" if @wr_binmode;
warn "WRITE BINMODE=@wr_binmode\n" if $verbose > 1 && @wr_binmode;

$book_sort_by_surname //= ! $book_sort_by_givenname;

s/^\W*// for @selection_tags,
             @inclusion_tags;

{

################################################################################
#
# Parse input file(s)
#
# Mostly we automatically adapt to the input format, so we can read
#  - CSV dumps from Drupal
#  - CSV dumps from Gmail (both UTF8 and UTF16LE)
#  - CSV input for the interrim label generator
#

sub open_file_for_reading($) {
    my $in_name = "(stdin)";
    my $in = shift;

    my $fsep = $csv_fs_char;
    my $echar = $csv_escape_char;
    my $qchar = $csv_quote_char;

    if (!ref $in) {
        # param is *not* a filehandle
        if (!$in || $in eq '-') {
            # param is '' or '-', use stdin
            $in = *STDIN{IO};
        }
        else {
            # param is filename, so open it
            $in_name = $in;
            $in = undef;
        }
    }

    warn "STARTING file '$in_name'\n" if $verbose;

    my @rd_binmode;
    my $rd_crlf = 1;
    if ($force_decoding) {
        #
        # we were told to expect a specific encoding; trust the user...
        # (this might be necessary if the input is a pipe, so we can't rewind it)
        #
        push @rd_binmode, ":encoding($force_decoding)" if $force_decoding ne 'OCTET';
    }
    else {
        #
        # deduce the encoding by reading the first 8KiB and looking for BOM and FS
        #
        open $in, '<:raw', $in_name or die "Can't open $in_name; $!\n" if !$in;
        local $/ = \8192;
        my $s = <$in>;
        my $seek_to = 0;
        my $decoding;

        $fsep = $&, $echar = $qchar = "" if !$fsep && $s =~ m/\t/;

        # Unicode \ufeff is Byte Order Mark, which looks like these:
        if ( $s =~ m{^     \xef\xbf\xbe
                    |^ (?: \x00\x00  |) \xfe\xff
                    |^     \xff\xfe (?: \x00\x00 |)
                    }x ) {
            # found a BOM
            my $rd_bom = $&;
            $seek_to = length($rd_bom);
            state $bom_to_encoding = {
                    "\xef\xbf\xbe"     => 'UTF-8',
                    "\xfe\xff"         => 'UTF-16BE',
                    "\x00\x00\xfe\xff" => 'UTF-32BE',
                    "\xff\xfe"         => 'UTF-16LE',
                    "\xff\xfe\x00\x00" => 'UTF-32LE',
            };
            $decoding = $bom_to_encoding->{$rd_bom};
        }
        elsif ( $presume_decoding && $presume_decoding ne 'OCTET' ) { $decoding = $presume_decoding; }
        else {
            if ( $s !~ m{ [^\x80-\xff][\x80-\xbf]
                        | [\xc0-\xff][^\x80-\xbf]
                        | [\xe0-\xff].[^\x80-\xbf]
                        | [\xf0-\xff]..[^\x80-\xbf]
                        | [\xf8-\xff]...[^\x80-\xbf]
                        | [\xfc-\xff]....[^\x80-\xbf]
                        | [\x00\xc0\xc1\xfe\xff]      }x ) { $decoding = 'UTF-8';    }
            elsif ( $s =~ m{^ \x00\x00\x00[\x20-\x7f] }x ) { $decoding = 'UTF-32BE'; }
            elsif ( $s =~ m{^ \x00[\x20-\x7f]         }x ) { $decoding = 'UTF-16BE'; }
            elsif ( $s =~ m{^ [\x20-\x7f]\x00\x00\x00 }x ) { $decoding = 'UTF-32LE'; }
            elsif ( $s =~ m{^ [\x20-\x7f]\x00         }x ) { $decoding = 'UTF-16LE'; }
            else                                           { $decoding = '';         }
            warn sprintf "Guessing %s for %s (no BOM)\n", $decoding || 'OCTET', $in_name;
        }
        push @rd_binmode, ":encoding($decoding)" if $decoding;
        seek $in, $seek_to, SEEK_SET or die "Cannot seek within $in_name; $!\n(char-set auto-detection unavailable)\n";
        $rd_crlf = $s =~ m{\r\n} ? 1 : 0;
    }
    push @rd_binmode, ":crlf" if $rd_crlf;
    unshift @rd_binmode, ':raw' if @rd_binmode;
    warn "READ BINMODE=@rd_binmode\n" if $verbose > 1 && @rd_binmode;
    if (!$in) {
        open $in, "<@rd_binmode", $in_name or die "Can't open $in_name [@rd_binmode]; $!\n";
    }
    else {
        binmode $in, "@rd_binmode" or die "Can't set binmode(@rd_binmode) on $in_name; $!\n" if @rd_binmode;
    }

    return $in, $in_name, $fsep, $echar, $qchar;
}

sub parse_file($) {
    my ( $in, $in_name, $fsep, $echar, $qchar ) = open_file_for_reading shift;

    my $filetype;
    $fsep ||= ',';
    $echar //= '"';
    $qchar //= '"';

    my $csv = Text::CSV::->new({ binary => 1, sep_char => $fsep, escape_char => $echar, quote_char => $qchar }) or die "Can't construct CSV reader; $!";

    my @headers = do {
            my $r0 = $csv->getline($in) or die "Can't get header line from $in_name\n";
            print "Read headers: " . Dumper($r0) if $verbose > 4 && $debug;
            $r0->[0] =~ s/^\x{fffe}// and die "Can't process $in_name -- starts with reverse BoM!\n";
            $r0->[0] =~ s/^\x{feff}// and warn "Ignoring leading BoM in $in_name\n";            # ignore Byte-Order-Mark
            $r0->[0] =~ s/^!// and warn "Ignoring leading ! in $in_name\n";     # a leading "!" may be used to force headers to sort to beginning of file
            if ($r0->[0] =~ /^%/) {
                $filetype = PDF::adhoc2::;
                # There is no "header row" as such, so the first row is actually structured data...
                $filetype->new(undef, $r0);
            }
            elsif ($r0->[0] eq 'uid') {
                $filetype = CSV::qndb::;
            }
            elsif ($r0->[0] eq 'Name') {
                $filetype = CSV::gmail::;
            }
            elsif ($r0->[0] eq 'inserts' ) {
                $filetype = CSV::adhoc1::;
            }
            else {
                die "Unknown file type, headers=[@$r0]\n";
            }
            map { s/\W+/_/g; lc $_ } @$r0;
        };
    warn "Parsed headers: " . Dumper(\@headers) if $verbose > 4 && $debug;

    my $num_lines = $. - 1;
    my @records;
    my %record_by_uid;
    $! = 0;
    RECORD: while ( my $ra = $csv->getline($in) ) {
        $num_lines = $. - 1;
        print "Read line#$num_lines: " . Dumper($ra) if $verbose > 5 && $debug;
        my @r = $filetype->new(\@headers, $ra);
        push @records, @r;
        $record_by_uid{$_->uid} = $_ for @r;
        $! = 0;
    }
  # warn "getline returned false; $!\n";
  # warn sprintf "%s at position: %2\$u %2\$#x\n", $in_name, tell($in);
  # if ( defined(my $x = <$in>) ) {
  #     warn sprintf "next line of input from %s: %s\n", $in_name, $x;
  # }
  # else {
  #     warn sprintf "reached end of file on %s\n", $in_name;
  # }
    warn sprintf "READ: parsed %u records from %u lines in %s\n", scalar(@records), $num_lines, $in_name if $verbose;
    warn sprintf "READ: file position now at %#x in %s\n", tell($in), $in_name if $verbose > 1;
    close $in or die "Error while reading $in_name; $!\n";

    RECORD: for my $r ( @records ) {
        if ( $r->{ZREF_parents} || $r->{ZREF_children} ) {
            $r->{XREF_parents}  = delete $r->{ZREF_parents};
            $r->{XREF_children} = delete $r->{ZREF_children};
        } else {
            my $uid = $r->uid;
            for my $uid_of_kid ($r->uid_of_children_under_16) {
                my $k = $record_by_uid{$uid_of_kid} or next RECORD;
                push @{$k->{LIST_uids_of_parents}}, $uid;
                push @{$k->{XREF_parents}}, $r;
                push @{$r->{XREF_children}}, $k;
            }
            if (my ($uid_of_spouse) = $r->uid_of_spouse) {
                my $s = $record_by_uid{$uid_of_spouse} or do { warn sprintf "Record with uid#%s (name:%s) claims spouse with uid#%s, who does not exist\n", $uid, $r->name, $uid_of_spouse; next; };
                $r->{XREF_spouse} = $s;
                $s->isa(CSV::Common::) or die "Not a CSV::Common record\n".Dumper($s);
                my ($s2uid) = $s->uid_of_spouse or do { warn sprintf "Record with uid#%s (name:%s) claims spouse with uid #%s, who has no spouse\n", $uid, $r->name, $uid_of_spouse; next; };
                $s2uid eq $uid or do { warn sprintf "Record with uid#%s (name:%s) claims spouse with uid #%s, who has a different spouse with uid#%s\n", $uid, $r->name, $uid_of_spouse, $s2uid; next; };
                $s->{XREF_spouse} = $r;
               #$r->isa(CSV::Common::) or die "Not a CSV::Common record ".Dumper($r);
            }
        }
    }

    warn sprintf "READ: cross-referenced %u records from %s\n", scalar @records, $in_name if $verbose;

    return \@records;
}

    sub _open_output($;$) {
        my $output = shift;
        my $raw = shift;
        my @binmode = $raw ? () : @wr_binmode;
        my @bom     = $raw ? () : @wr_bom;
        flush STDOUT;
        flush STDERR;
        if ($output && ! ref $output && $output ne '-') {
            $force_overwrite || ! -e $output or die "Output file '$output' already exists; use --force-overwrite\n";
            open my $outx, ">@binmode", $output or die "Can't create $output; $!\n";
            print $outx @bom if @bom;
            return $outx, $output;
        }
        else {
            state %first;
            ref $output or $output = *STDOUT{IO};
            if ( !$first{$output}++ ) {
                binmode $output, "@binmode" or warn "Can't set binmode on $output (@binmode); $!\n" if @binmode;
                print $output @bom if @bom;
            }
            return $output, '(stdout)';
        }
    }

    sub _choose_ofields() {
        my @ofields;
        # 'name' is not required; always printed, separately from fields list
        push @ofields, qw( monthly_meeting_area formal_membership inactive ) unless $names_only || $suppress_status;
        push @ofields, qw( show_me_in_young_friends_listing ) unless $names_only || $suppress_yf_listing;
        push @ofields, qw( listed_email phone_number mobile_number fax listed_address postal_address ) unless $names_only;
        push @ofields, qw( receive_local_newsletter_by_post nz_friends_by_post) unless $names_only || $suppress_send_by_post;
        push @ofields, qw( receive_local_newsletter_by_email nz_friends_by_email ) unless $names_only || $suppress_send_by_email;
                       # Possible additional fields:
                       #   synthesized website_url rd_no po_box_number country postcode
                       #   town suburb address property_name users_name
                       #   uid_of_children_under_16 uid_of_spouse uid first_name
                       #   family_name
        push @ofields, qw( uid uid_of_spouse uid_of_children_under_16 uids_of_parents ) if $show_uid;
        return grep { ! /^#/ } @ofields;
    }

    sub _dump_one($$$) {
        my ($out, $r, $ofields) = @_;
        my $ov = $verbose;
        {
            # Fixed fields: name, sort-keys, birthday
            my $v = $r->name || do { warn "UNNAMED RECORD\n" . ::Dumper($r); '(unknown)' };
            if ($show_hyperlinks and my $ru = $r->uid) {
                if ($ru !~ /^GEN/) {
                    my $rl = show_qonu($ru);
                    $v .= "  $rl";
                }
            }
            if ($r->can("gtags") && $r->gtags("suppress listing")) {
                $v .= "  [SUPPRESSED LISTING]";
            }
            printf $out "%s: %s\n", "name", $v;
            printf $out "%s: %s\n", "sort-by-surname", $r->{composite_name}->{sort_by_surname};
            printf $out "%s: %s\n", "sort-by-givenname", $r->{composite_name}->{sort_by_givenname};
            if ( my $bd = $r->birthdate ) {
                if ( ! $suppress_adult_birthdays
                    || $bd =~ m#^(\d{4})\W*(\d{2})\W*(\d{2})(?:T[:0-9]{8}|\W*)$# && "$1$2$3" ge sixteen_this_date && "$1$2$3" le this_date && "$1$2$3" ge '18900000') {
                    $bd = show_date($bd);
                    printf $out "%s: %s\n", 'Birthday', $bd;
                }
            }
        }
        FIELD: for my $f (@$ofields) {
            my @v;
            if (my $ff = $r->can($f)) {
                @v = $ff->($r);
                #push @v, "can($f)";
            }
            elsif (exists $r->{"LIST_$f"}) {
                @v = @{ $r->{"LIST_$f"} };
                #push @v, "_list($f)";
            }
            elsif (exists $r->{$f}) {
                @v = $r->{$f} // ();
                #push @v, "{$f}";
            }
            else {
                if ($verbose > 1) {
                    warn "Missing field '$f' in $r\n".Dumper($r);
                }
                elsif ($verbose) {
                    warn "Missing field '$f' in $r\n";
                }
            }
            @v = grep { defined $_ && "$_" ne '' } @v;
            defined $v[0] or next FIELD;
            if (my $fn = $show_fields{$f}) {
                $_ = $fn->($_) for @v
            }
            for my $v (@v) {
                if ($v =~ /\n/) {
                    printf $out "%s:\n%s\n", $f, $v;
                }
                else {
                    printf $out "%s: %s\n", $f, $v;
                }
            }
        }
        if ($show_relationships) {
            if ( my $s = $r->{XREF_spouse} ) {
                #$s->isa(CSV::Common::) or die "Not a CSV::Common record: ".Dumper($s);
                my $v = $s->name || '(unknown)';
                if ($show_hyperlinks and my $su = $s->uid) {
                    my $sl = show_qonu($su);
                    $v .= "  $sl";
                }
                printf $out "%s: %s\n", "spouse", $v;
            }
            if (my $pp = $r->{XREF_parents}) {
                for my $p ( preferred_sort @$pp ) {
                    #$p->isa(CSV::Common::) or die "Not a CSV::Common record: ".Dumper($p);
                    my $v = $p->name || '(unknown)';
                    if ($show_hyperlinks and my $pu = $p->uid) {
                        my $pl = show_qonu($pu);
                        $v .= "  $pl";
                    }
                    printf $out "%s: %s\n", "parent", $v;
                }
            }
            if (my $cc = $r->{XREF_children}) {
                for my $c ( preferred_sort @$cc ) {
                    #$c->isa(CSV::Common::) or die "Not a CSV::Common record: ".Dumper($c);
                    my $v = $c->name || '(unknown)';
                    if ($show_hyperlinks and my $cu = $c->uid) {
                        my $cl = show_qonu($cu);
                        $v .= "  $cl";
                    }
                    printf $out "%s: %s\n", "child", $v;
                }
            }
        }
      # die Dumper($r) if $r->name =~ /Beryl\s*Riley/;
        print $out Dumper($r) if $verbose > 4 && $debug;
        $verbose = $ov;
    }

################################################################################
#
# Generate a report of differences between two files
#

    # Take two lists, and expand them with undefs so that equal elements line up.
    # Work by picking the longest common subsequence, then recursively operating
    # on the parts either side of that.
    # If there are no equal elements, just pad the two lists to the same length.
    sub _diff_align(&\@\@) {
        my ($cmp, $l1, $l2) = @_;
        #my $verbose = $#$l1 + $#$l2 > 6;
        my @stack = [ 0, $#$l1, 0, $#$l2 ];
        #flush STDOUT if $verbose;
        #warn "START\n" if $verbose;
        while (my $q = pop @stack) {
            #warn "STEP: ".Dumper(["RANGE", $q, "LIST1", $l1, "LIST2", $l2, "STACK", \@stack]) if $verbose;
            my ( $s1, $e1, $s2, $e2) = @$q;
            my $d = ($e1-$s1) - ($e2-$s2);
            if ($s1 > $e1) {
                #warn sprintf "INSERT %u into LIST1 at %u\n", -$d, $e1+1 if $verbose;
                splice @$l1, $e1+1, 0, (undef) x -$d;
                next;
            }
            if ($s2 > $e2) {
                #warn sprintf "INSERT %u into LIST2 at %u\n", $d, $e2+1 if $verbose;
                splice @$l2, $e2+1, 0, (undef) x $d;
                next;
            }
            # find maximal common stretch, with minimal offset from the centres
            my $ml = int( (($e1-$s1) + ($e2-$s2)) / 2 );
            my $mo = int( (($e1-$s1) - ($e2-$s2)) / 2 );
            my $pos;
            my $off;
            my $len = 0;
            for my $o ( $mo, map { $mo+$_, $mo-$_ } 1 .. $ml+1 ) {
                my $i = ::max($s1, $s2-$o);
                my $e = ::min($e1, $e2-$o);
                #warn sprintf "CHECK LIST1[%d..%d] against LIST2[%d..%d]\n", $i, $e, $i+$o, $e+$o if $verbose;
                for (; $i <= $e ;++$i) {
                    if ( $cmp->($l1->[$i], $l2->[$i+$o]) ) {
                        my ($z) = grep { !$cmp->($l1->[$_], $l2->[$_+$o]) } $i .. $e;  # index of next non-matching element
                        $z //= $e+1;            # if all the rest match, then there is no "next non-matching element"
                        if ($len < $z-$i) {
                            # found a new longest subset
                            $len = $z-$i;
                            $pos = $i;
                            $off = $o;
                        }
                        $i = $z;
                    }
                }
            }
            if (defined $pos) {
                # found a common subset; perform alignment on the parts either side
                #warn sprintf "COMMON %u at LIST1[%u..%u] and at LIST2[%u..%u]\n", $len, $pos, $pos+$len-1, $pos+$off, $pos+$off+$len-1 if $verbose;
                push @stack, [ $s1,       $pos-1, $s2,            $pos+$off-1 ],
                             [ $pos+$len, $e1,    $pos+$off+$len, $e2         ];
            }
            else {
                #warn sprintf "ALLDIFF\n" if $verbose;
                if ($d<0) {
                    splice @$l1, $e1+1, 0, (undef) x -$d;
                }
                else {
                    splice @$l2, $e2+1, 0, (undef) x $d;
                }
            }
        }
        #warn "DONE\n" if $verbose;
    }

use quaker_info '$mm_keys_re';

    sub _skip_restricted_record($) {
        my $r = shift;

        if (@restrict_regions) {
            my $skip = 0;
            if ( $r->can('gtags') ) {
                $r->isa(CSV::qndb::) and die "gtags shouldn't work on QNDB record; method=".$r->can('gtags');
              # if ( my @mt = map { m{^(?:member|listing|send|post)[- ]+($mm_keys_re)\s} ? $1 : () } $r->gtags ) { ... }
                if ( my @mt = $r->gtags( qr/^(?:member|listing)[- ]+($mm_keys_re|YF)\b/ ) ) {
                    grep { my $reg = $_; grep { $_ eq $reg } @mt } @restrict_regions
                    or $skip = 1;
                }
                elsif ($need_region) {
                    $skip = 2;
                }
            }
            else {
                if ( my @mt = map {
                                    my $a = $r->{$_} || '';
                                    $a =~ m{^($mm_keys_re|YF)\b} ? $1 : ()
                                } qw{   formal_membership
                                        monthly_meeting_area
                                       } ) {
                                    # Also, maybe:
                                    # - receive_local_newsletter_by_post
                                    # - receive_local_newsletter_by_email
                    grep {
                            my $reg = $_;
                            grep { $_ eq $reg } @mt;
                        } @restrict_regions
                    or $skip = 3;
                }
                elsif ($need_region) {
                    $skip = 4;
                }
            }
            if ($skip) {
                warn sprintf "Skipping line#%s cause=%s name=%s, mm=%s fm=%s\n",
                            $r->{__source_line}, $skip, $r->{composite_name},
                            ref $r->{monthly_meeting_area} ? join ',', @{$r->{monthly_meeting_area}} : $r->{monthly_meeting_area} || '(none)',
                            $r->{formal_membership} || '(none)',
                    if $why_not || $verbose > 2;
                return 1;
            }
        }
        if ( $r->can('gtags') ) {
            if ($need_region) {
                if ( ! $r->gtags( qr/^(?:member|listing)[- ]+($mm_keys_re|YF)\b/ ) ) {
                    warn sprintf "Skipping line#%s uid#%s name=%s NO LISTING\n", $r->{__source_line}, $r->uid, $r->name if $why_not;
                    return 1;
                }
            }
            if ($skip_archived) {
                if ( my @s = $r->gtags( qr/^archive - (.*)/ ) ) {
                    warn "Skipping line#$r->{__source_line} ".$r->name." ARCHIVE @s\n" if $why_not;
                    return 1;
                }
            }
            state $skips = do {
                my @skips;
                push @skips, 'archive - deceased'     if $skip_deceased && !$skip_archived;
                push @skips, 'archive - unsubscribed' if $skip_unsub    && !$skip_archived;
                push @skips, 'meetings'               if $skip_meetings;
                push @skips, 'suppress listing'       if $skip_suppressed_listing;
                push @skips, 'newsletters-only'       if $skip_newsletters_only;
                push @skips, 'suppress email'         if $skip_suppressed_email;
                push @skips, 'suppress post'          if $skip_suppressed_post;
                \@skips;
            };
            if ( @$skips && $r->gtags(@$skips) ) {
                warn "Skipping line#$r->{__source_line} ".$r->name." because found [@$skips]\n" if $why_not;
                return 1;
            }
        }
      # elsif ( UNIVERSAL::isa($r, PDF::adhoc2::) ) {
      #     return 0;
      # }
        else {
            if ($skip_meetings && (! $r->{monthly_meeting_area} &&
            ! $r->{formal_membership} &&
            ! ( $r->{show_me_in_young_friends_listing}
             && $r->{show_me_in_young_friends_listing} eq 'Yes' ))) {
                warn "Skipping line#$r->{__source_line} ".$r->name." because [no mm area, no formal membership, and no yf listing]\n" if $why_not;
                return 1;
                #$r->name =~ /Bakke/ and die Dumper($r);
            }
        }
        if ( $diff_ignore_file ) {
            state $things_to_ignore = do {
                my %ignore_uid;
                my %ignore_name;

                my ( $in, $in_name ) = open_file_for_reading $diff_ignore_file;

                my @f = <$in>;
                close $in or die "Couldn't read '$in_name'; $!\n";
                for my $f (@f) {
                    chomp $f;
                    $f =~ s/\#.*//;
                    $f =~ s/\s+$//;
                    next if !$f;
                    if ($f =~ /^\d/) {
                        $ignore_uid{$f} = 1;
                    } else {
                        $ignore_name{lc $f} = 1;
                    }
                }
                warn "Loading ignorance table, ".(0+%ignore_uid)." uids and ".(0+%ignore_name)." names\n" if $verbose;
                warn Dumper( \%ignore_uid, \%ignore_name ) if $verbose > 2;
                [ \%ignore_uid, \%ignore_name ]
            };
            if ($things_to_ignore->[0]{$r->uid}) {
                warn "Skipping line#$r->{__source_line} ".$r->name." [ignoring uid]\n" if $why_not;
                return 1;
            }
            if ($things_to_ignore->[1]{lc $r->name}) {
                warn "Skipping line#$r->{__source_line} ".$r->name." [ignoring name]\n" if $why_not;
                return 1;
            }
        }
        return 0;
    }

    sub show_one_diff($$$$) {
        my ($out, $r1, $r2, $ofields) = @_;
        state $fmt = "%-18.18s %-32s %-3.3s %s";
        my $said_title;
        if ($r1) {
            my $name1 = $r1->name;
            my $uid1  = $r1->uid;
            my $suid1 = show_qonu($uid1);
            if ($r2) {
                my $name2 = $r2->name;
                my $uid2  = $r2->uid;
                my $suid2 = show_qonu($uid2);
                if ( $name1 ne $name2) {
                    #printf $out "\n$fmt\n", 'RENAME', $name1, '===', $name2, $suid1 || $suid2;
                    printf $out "\nRENAME #%-8s %s === %s  %s\n", $uid2 || $uid1, $name1, $name2, $suid1 || $suid2;
                    $said_title++;
                    if ( $suid1 && $suid2 && $uid1 ne $uid2 ) {
                        printf $out "$fmt  (%s === %s)\n", 'RENUMBER', $uid1, '===', $uid2, $suid1, $suid2;
                    }
                    else {
                    }
                }
                elsif ( $suid1 && $suid2 && $uid1 ne $uid2 ) {
                    printf $out "\nMODIFY #%-8s %s %s\n", $uid2, $name2, $suid2;
                    $said_title++;
                    printf $out "$fmt  (%s === %s)\n", 'RENUMBER', $uid1, '===', $uid2, $suid1, $suid2;
                }
                FIELD: for my $f ( @$ofields ) {
                    my (@v1, @v2);
                    for my $z ( [$r1, \@v1], [$r2, \@v2] ) {
                        my $r = $z->[0];
                        my @v;
                        if (my $ff = $r->can($f)) {
                            @v = $ff->($r);
                        }
                        elsif (exists $r->{"LIST_$f"}) {
                            @v = @{ $r->{"LIST_$f"} };
                        }
                        elsif (exists $r->{$f}) {
                            @v = $r->{$f} // ();
                        }
                        else {
                            warn "Missing field '$f' in $r\n" if $verbose;
                        }
                        @{ $z->[1] } = map { split /\n/, $_ } grep { defined $_ && "$_" ne '' } @v;
                    }
                    if ( $#v1 != $#v2 || grep { $v1[$_] ne $v2[$_] } 0..$#v1 ) {
                        if (!$said_title++) {
                            printf $out "\nMODIFY #%-8s %s  %s\n", $uid2, $name2, $suid2;
                        }
                        my $said_label;
                        _diff_align { $_[0] ne '' && $_[0] eq $_[1] } @v1, @v2;
                        for my $i ( 0 .. ::max $#v1, $#v2 ) {
                            my $vl1 = $v1[$i] || '';
                            my $vl2 = $v2[$i] || '';
                            next if $diff_quietly && $vl1 eq $vl2;
                            my $cmp = ( $vl1 eq '' ? '-' : '=' ) . ( $vl1 eq $vl2 ? '=' : '!' ) . ( $vl2 eq '' ? '-' : '=' );
                            printf "$fmt\n", $said_label++ ? '' : "$f", $vl1 || ' (add)', $cmp, $vl2 || ' (del)';
                        }
                    }
                }
            }
            else {
                # deletion
                printf $out "\nDELETE #%-8s %s  %s\n", $uid1, $name1, $suid1;
            }
        }
        else {
            if ($r2) {
                my $name2 = $r2->name;
                my $uid2  = $r2->uid;
                my $suid2 = show_qonu($uid2);
                printf $out "\nINSERT #%-8s %s  %s\n", $uid2, $name2, $suid2;
                _dump_one $out, $r2, $ofields;
            }
            else {
                printf $out "\nBROKEN: double null records\n";
                die "NOTREACHED";
            }
        }
    }

sub generate_diff($$$$$) {
    my ($out, $rr1, $in1, $rr2, $in2 ) = @_;
    $in1 ||= '(stdin)';
    $in2 ||= '(stdin)';

    warn sprintf "DIFF: comparing %u record from %s with %u records from %s\n", scalar @$rr1, $in1, scalar @$rr2, $in2 if $verbose;
    my @ofields = _choose_ofields;

    my @rr1 = preferred_sort grep { !_skip_restricted_record $_ } @$rr1;
    my @n1 = map { $_->name . '' } @rr1; my %kn1; @kn1{@n1} = 0 .. $#n1;
    my @u1 = map { $_->uid } @rr1;       my %ku1; @ku1{@u1} = 0 .. $#u1;

    my @rr2 = preferred_sort grep { !_skip_restricted_record $_} @$rr2;
    my @n2 = map { $_->name . '' } @rr2; my %kn2; @kn2{@n2} = 0 .. $#n2;
    my @u2 = map { $_->uid } @rr2;       my %ku2; @ku2{@u2} = 0 .. $#u2;

    my $can_map_uid  = $diff_by ne 'name' && ! grep { ! $_ } @n1, @n2;
    my $can_map_name = $diff_by ne 'uid'  && ! grep { ! $_ } @u1, @u2;

    $can_map_uid or $can_map_name or die "Can map by neither UID nor Name, due to missing values of both\n";

    ( $out, my $out_name ) = _open_output $out;

    if ($can_map_uid) {
        for my $uid ( ::uniq @u2, @u1 ) {
            my $suid = show_qonu($uid);
            my $i1 = $ku1{$uid};
            my $r1 = defined $i1 && $rr1[$i1];
            my $i2 = $ku2{$uid};
            my $r2 = defined $i2 && $rr2[$i2];
            if ($r1) {
                $r1->uid eq $uid or die "A Missed UID #$uid in ".Dumper($r1)."\n".Dumper([\%ku1, \%kn1, \@rr1, \%ku2, \%kn2, \@rr2,]);
            }
            if ($r2) {
                $r2->uid eq $uid or die "B Missed UID #$uid in ".Dumper($r2)."\n".Dumper([\%ku1, \%kn1, \@rr1, \%ku2, \%kn2, \@rr2,]);
            }
            show_one_diff $out, $r1, $r2, \@ofields;
        }
    }
    elsif ($can_map_name) {
        for my $name ( ::uniq @n2, @n1 ) {
            my $i1 = $kn1{$name};
            my $r1 = defined $i1 && $rr1[$i1];
            my $i2 = $kn2{$name};
            my $r2 = defined $i2 && $rr2[$i2];

            if ($r1) {
                $r1->name eq $name or die "A Missed name '$name' in ".Dumper($r1)."\n".Dumper([\%ku1, \%kn1, \@rr1, \%ku2, \%kn2, \@rr2,]);
            }
            if ($r2) {
                $r2->name eq $name or die "A Missed name '$name' in ".Dumper($r2)."\n".Dumper([\%ku1, \%kn1, \@rr1, \%ku2, \%kn2, \@rr2,]);
            }
            show_one_diff $out, $r1, $r2, \@ofields;
        }
    }
}

################################################################################
#
# Dump records in a textual form that allows easy inspection and comparison;
# - record as blank-line separated paragraph
# - multivalue fields split into separate (identically named) fields
# - fields on separate lines
# - postal & street addresses in multiline format
#

sub diffably_dump_records($$;$) {
    my $out = shift;
    my $rr = shift;
    my $in_name = shift || '(stdin)';

    warn sprintf "DUMP: dumping %u records from %s\n", scalar @$rr, $in_name if $verbose;

    ( $out, my $out_name ) = _open_output $out;
    my @ofields = _choose_ofields;
    my @records = @$rr;
    #print Dumper(\@records);
    @records = preferred_sort @records;
    #print Dumper(\@records);
    RECORD: for my $r (@records) {
        _skip_restricted_record $r and do {
            warn sprintf "DUMP: skipping #%s (%s)\n", $r->{__source_line}, $r->{name} // '' if $verbose > 2;
            next RECORD;
        };
        print $out "\n";
        _dump_one $out, $r, \@ofields;;
    }
    close $out or die "Error while writing to $out_name; $!\n";
}

################################################################################
#
# Generate a Google import csv that includes the various qdb* fields, so these
# imported records can be merged with the existing ones to incorporate those
# new fields.
#

    sub notno($) {
        (my $z) = @_;
        return defined $z && $z =~ /^[Yy1]$|^yes$/i;
    }

sub generate_qndb_map($$;$) {
    my $out = shift;
    my $rr = shift;
    my $in_name = shift || '(stdin)';
    ( $out, my $out_name ) = _open_output $out;
    my %rr = map { ( $_->uid => $_ ) } @$rr;
    print $out "Name,Group Membership,Custom Field 1 - Type,Custom Field 1 - Value,Custom Field 2 - Type,Custom Field 2 - Value,Custom Field 3 - Type,Custom Field 3 - Value\n";
    my @records = preferred_sort @$rr;
    RECORD: for my $r (@records) {
        my $fullname = $r->name || next RECORD; #die "Missing name\n".Dumper($r);
        my $qdb = $r->uid || die "missing uid\n".Dumper($r);
        my $spouse = $r->{uid_of_spouse} // die "mssing spouse-uid\n".Dumper($r); #$r->uid_of_spouse;
        my @uids_of_kids = $r->uid_of_children_under_16; #// die "missing children-uid\n".Dumper($r); #$r->uid_of_children_under_16;
        my @uids_of_parents = $r->_list('uids_of_parents');
        my @groups = '* My Contacts';
        my $l = $r->{monthly_meeting_area};
        push @groups, '@listing - '.$l if $l;
        if (my $m = $r->{formal_membership}) {
            if ( $l && substr($m,0,3) eq substr($l,0,3) && $l !~ /overseas|elsewhere/i ) {
                $m = $l;
            }
            push @groups, '@member - '.$m, '#member';
        }
        elsif ( ! notno $r->{inactive} ) {
            push @groups, '#attender';
        }
        else {
            push @groups, '#inactive';
        }
        push @groups, '!post NZ Friends' if notno $r->{nz_friends_by_post};
        push @groups, '!send NZ Friends' if notno $r->{nz_friends_by_email};
        push @groups, '@listing - YF'    if notno $r->{show_me_in_young_friends_listing};
        if (my $n = $r->{receive_local_newsletter_by_post}) {
            push @groups, '!post '.$n;
        }
        printf $out "%s,%s,qdb,%s,qdb-spouse,%s,qdb-parent,%s,qdb-child,%s\n", $fullname, join(' ::: ', @groups), $qdb, $spouse, join(' ::: ', @uids_of_parents), join(' ::: ', @uids_of_kids);
    }
    close $out or die "Error while writing to $out_name; $!\n";
}

################################################################################
#
# Generate postage labels as a printable PDF file
#     parameters: a list of tags; a description of the label layout
#
# Using "!post {tag}" as a category, select all the records from that category
# Gather all the records from all such categories
# Group them by families (spouse & children links)
# Make a label for each family:
# - Make a summary addressee line;
#   - for one person, use their full name
#   - for two people (any relationship), use "X Jones & Y Smith" or "X & Y
#     Smith" (child last, if applicable)
#   - for one adult and two or more children, use "X Jones & family"
#   - for two adults and one or more children, use "X & Y Smith & family" or "X
#     Jones & Y Smith & family"
# - Make an inclusions list from the union of all the categories that apply on
#   any of the family members
# - include the postal address; separately, the country & postcode
# Group the labels by tag-sets
# Generate PDF, generating control labels at the top of each page and before any
# change of tag-set
#

################################################################################

=head 3

Label records

=cut

    {
    package CommonLabel;

    use verbose;
    use PDF::scale_factors;

    sub new {
        my $class = shift;
        bless { @_ }, $class;
    }

    use constant colour => 'black';

    sub draw_label {
        my ($r, $pq, $top, $left, $label_on_page) = @_;
        my $text = $pq->text;
        $text->fillcolor($r->colour);

        my @lines = @{$r->{lines}};
        my $banner = $r->{banner};

        @lines || $banner || return;

        my $active_fontsize = $label_fontsize;
        my $current_fontsize = $label_fontsize;

        $pq->font( $label_fontname, $active_fontsize );

        if ($evenly_squash_to_fit) {
            # squash up when too many lines
            # evenly squash up ALL lines when any line is too wide
            my $printable_label_width  = $label_width  - $label_left_margin - $label_right_margin;
            my $printable_label_height = $label_height - $label_top_margin  - $label_bottom_margin;
            $active_fontsize *= ::min 1,
                                      $printable_label_height / ( @lines + ($banner && $label_banner_scale || 0) ) / ( $line_spacing * $active_fontsize ),
                                      $printable_label_width / ::max 1,
                                                                     $banner && $text->advancewidth($banner)*$label_banner_scale || 0,
                                                                     map { $text->advancewidth($_) } @lines;
        }

        if (my $p = $r->{banner}) {
            if (my @v = $p =~ m/\%\{(\w+)\}/g) {
                warn "format '$p' keys [@v]\n" . Dumper($r) if $verbose > 2;
                $p =~ s/\%\{(\w+)\}/%/g;
                $p = sprintf $p, @$r{@v};
            }
            $active_fontsize = ::min $active_fontsize,
                                     $label_height / ($label_banner_scale * $line_spacing + @lines * $line_spacing);

            my $banner_fontsize = $active_fontsize*$label_banner_scale;
            $pq->font( $label_banner_font, $current_fontsize = $banner_fontsize ) if $banner_fontsize != $current_fontsize;
            $text->translate( $left, $top -= $banner_fontsize*$line_spacing );
            $text->text($p);
        }

        if (@lines) {
            for (0 .. $#lines) {
                $pq->font( $label_fontname, $current_fontsize = $active_fontsize ) if $active_fontsize != $current_fontsize;
                my $rescale = $label_width / $text->advancewidth($_);
                if ( $rescale < 1 ) {
                    # squeeze up to make room...
                    $pq->font( $label_fontname, $current_fontsize = $active_fontsize * $rescale );
                }
                $text->translate( $left, $top - (@lines - $#lines + $_)*$active_fontsize*$line_spacing );
                $text->text($lines[$_]);
            }
        }

        if (my $p = $r->{postcode}) {
            $pq->font( $label_fontname, $label_postcode_fontsize );
            $text->translate( $left + $label_width, $top - $label_height + $label_postcode_fontsize );
            $text->text_right($p);
        }

        warn sprintf "Page %u label %u -> lines=%u font=%.2fmm (%.2fpt)\n",
                    $pq->pages,
                    $label_on_page,
                    0+@lines,
                    $active_fontsize/mm, $active_fontsize/pt
            if $verbose > 1;
    }
    }

    {
    package BlankLabel;
    use parent -norequire => CommonLabel::;
    sub one { state $x = bless {}, shift }
    sub new { die }
    sub draw_label {}   # do nothing
    }

    {
    package ItemCountLabel;
    use parent -norequire => CommonLabel::;

    sub colour { $label_banner_colour }

    use verbose;
    use PDF::scale_factors;

    sub new {
        my $class = shift;
        my ($inclusions, $total_count, $first_label_on_page, $last_label_on_page) = splice @_,0,4;
        $inclusions = [ split /,\s*/, $inclusions ] if ! ref $inclusions;
        $class->SUPER::new(
            banner          => sprintf( "%u", $last_label_on_page-$first_label_on_page+1, ),
            lines           => $inclusions,
            first_on_page   => $first_label_on_page,
            last_on_page    => $last_label_on_page,
            total_count     => $total_count,
            @_
        );
    }
    sub draw_label {
        my ($r, $pq, $top, $left, $label_on_page) = @_;
        my $text = $pq->text;
        my $first_label_on_page = $r->{first_on_page};
        my $last_label_on_page = $r->{last_on_page};
        warn sprintf "Printing tiny labels #%u..%u", $first_label_on_page, $last_label_on_page if $verbose > 1;
        my $printable_label_width  = $label_width  - $label_left_margin - $label_right_margin;
        my $printable_label_height = $label_height - $label_top_margin  - $label_bottom_margin;
        my $labels_per_page = $num_labels_across * $num_labels_down;

        my $tiny_label_step_across = $printable_label_width / 3 / $num_labels_across;
        my $tiny_label_step_down   = $printable_label_height / $num_labels_down;
        my $tiny_fontsize = $tiny_label_step_down / $line_spacing;
        warn sprintf "Tiny labels fontsize=%.2fmm (%.2fpt), step-across=%.2fmm, step-down=%.2fmm ",
                    $tiny_fontsize/mm, $tiny_fontsize/pt,
                    $tiny_label_step_across/mm,
                    $tiny_label_step_down/mm
            if $verbose > 2;
        $pq->font( $label_fontname, $tiny_fontsize );
        for my $tiny_l ( 0 .. $labels_per_page-1 ) {
            my $tiny_col;
            my $tiny_row;
            if ($labels_ordered_in eq 'columns') {
                $tiny_row  = $tiny_l             % $num_labels_down;
                $tiny_col  = ($tiny_l-$tiny_row) / $num_labels_down;
            }
            else {
                $tiny_col  = $tiny_l             % $num_labels_across;
                $tiny_row  = ($tiny_l-$tiny_col) / $num_labels_across;
            }
            my $tiny_top  = $top  - $label_top_margin                               - $tiny_label_step_down   * $tiny_row;
            my $tiny_right = $left + $label_left_margin + $printable_label_width*2/3 + $tiny_label_step_across * ($tiny_col+1);
            warn sprintf "Printing tiny label #%s →%.2fmm,↑%.2fmm", $tiny_l, $tiny_right/mm, $tiny_top/mm if $verbose > 2;
            $text->translate( $tiny_right, $tiny_top - $tiny_label_step_down );
            if ( $tiny_l == $label_on_page ) {
                $text->fillcolor($label_banner_colour);
                $text->text_right("O");
            }
            elsif ( $tiny_l >= $first_label_on_page && $tiny_l <= $last_label_on_page ) {
                $text->fillcolor('black');
                $text->text_right("X");
            }
            else {
                $text->fillcolor('black');
                $text->text_right("-");
            }
        }
        $r->SUPER::draw_label($pq, $top, $left, $label_on_page);
    }
    }

    {
    package TotalCountLabel;
    use parent -norequire => CommonLabel::;
    sub new {
        my $class = shift;
        my ($inclusion_labels, $counts) = @_;
        bless {
            banner => "Totals",
            lines => [ map { sprintf "%3u× %s", $counts->[$_], $inclusion_labels->[$_] } grep { $counts->[$_] } 0..$#$inclusion_labels ],
        }, $class;
    }
    }

    {
    package HouseHoldLabel;
    use parent -norequire => CommonLabel::;

    sub new {
        my $class = shift;
        my ($inclusions, $postcode, @lines) = @_;
        bless {
                inclusions => $inclusions,
                lines    => \@lines,
                postcode => $postcode,
            }, $class;
    }

    use constant colour => 'black';

    }

##  {
##  package InfoLabel;
##  use parent -norequire => CommonLabel::;
##  sub fix_one {
##      my $r = shift;
##      $r->SUPER::fix_one(@_);
##      my @inserts = sort split /\s*,\s*/, $r->{inserts} // '';
##      $r->{inserts} = join ',', @inserts;
##      $r->{LIST_insert} = \@inserts;
##      $r->{HAS_insert} = { map { ( $_ => 1 ) } @inserts };
##      1;
##  }
##  }


    sub suppress_unwanted_records($) {
        my $rr = shift;
        if ( @$rr && $rr->[0]->isa(CSV::gmail::) ) {
            my @rr = @$rr;
            my @skips;
            push @skips, 'archive - deceased'     if $skip_deceased;
            push @skips, 'archive - unsubscribed' if $skip_unsub;
            push @skips, 'meetings'               if $skip_meetings;
            push @skips, 'suppress listing'       if $skip_suppressed_listing;
            push @skips, 'newsletters-only'       if $skip_newsletters_only;
            push @skips, 'suppress email'         if $skip_suppressed_email;
            push @skips, 'suppress post'          if $skip_suppressed_post;
            push @skips, 'explanatory texts';
            @rr = grep { ! $_->gtags(@skips) } @rr if @skips;
            @rr = grep { ! $_->gtags(qr/^archive - /) } @rr if $skip_archived;
            $rr = \@rr;
        }
        return $rr;
    }

    sub group_people_into_households($) {
        my $rr = shift;
        $rr = suppress_unwanted_records $rr;
        @$rr or return [];
        if ( 1 || $rr->[0]->can('uid') ) {
            my @households;
            my $unique_id = 0;
            my %s;
            for my $r (@$rr) {
                $s{$r->uid} and next;
                $r->{XREF_parents} and next;
                my @h = $r;
                push @h, $r->{"XREF_spouse"} if $r->{"XREF_spouse"};
                push @h, @{ $r->{"XREF_children"} } if $r->{"XREF_children"};
                $s{$_->uid}++ for @h;
                push @households, \@h;
            }
            return \@households;
        }
        elsif ( $rr->[0]->isa(CSV::gmail::) ) {
            my %households;
            for my $r (@$rr) {
                my $a = $r->postal_address or next;
                push @{$households{$a}}, $r;
            }
            return [ values %households ]
        }
        else {
            die "Can't group households of $rr->[0]";
        }
    }

sub generate_labels($$;$) {
    my $out = shift;
    my $rr = shift;
    my $in_name = shift || '(stdin)';

    # Make family groups or households
    my $households = group_people_into_households $rr;

    warn sprintf "grouped-households: %u\n", 0+@$households if $verbose;

    # Select households which have any member wanting any of the offered
    # inclusions

    @$households = grep { grep { $_->gtags(@selection_tags) } @$_; } @$households if @selection_tags;

    # Group households by which inclusions they want, and remove members of
    # households who want nothing

    my %inclusion_label; @inclusion_label{@inclusion_tags} = @inclusion_labels;

    warn sprintf "selected-households: %u\nselection-tags: [%s]\ninclusion-tags: [%s]\ninclusion-labels: [%s]\n",
            0+@$households,
            join('; ', @selection_tags),
            join('; ', @inclusion_tags),
            join('; ', @inclusion_labels)
        if $verbose;

    my %inclusion_counts;
    my %households_by_inclusions;
    HOUSEHOLD: for my $hh (@$households) {
        # Which members of household are requesting at least one item?
        my @hh = @$hh;
        @hh = grep { $_->gtags(@selection_tags) } @hh if @selection_tags;
        @hh or next HOUSEHOLD;
        # Which inclusions for this household?
        my @inclusions = map { $inclusion_label{$_} }
                            grep { my $t = $_; grep { $_->gtags($t) } @hh; }
                                @inclusion_tags
            or next HOUSEHOLD;
        my $inclusions = join ', ', @inclusions;
        $hh[0]->{inclusions} = $inclusions;
        my $postal_address = $hh[0]->postal_address;
        # What sort-order within the tag group?
        my @sort_by = qw( country postcode city suburb street streetnum );
        $hh[0]->{sort_by} = join "\t", map { $postal_address->{$_} || '' } @sort_by;
        # and done
        push @{$households_by_inclusions{$inclusions}}, \@hh;
        ++$inclusion_counts{$_} for @inclusions;
    }

    keys %households_by_inclusions > 0 or warn "No households selected; remember to use the GMail dump rather than the Profile dump\n";

    #print "DEBUG: households_by_inclusions:\n", Dumper(\%households_by_inclusions) if $verbose > 4 && $debug;
    if ($verbose > 2) {
        for my $hh (values %households_by_inclusions) {
            for my $h (@$hh) {
                printf "NAME: %s SORT: %s INCLUDE: %s\n", $h->[0]->name, $h->[0]->{sort_by}, $h->[0]->{inclusions};
            }
        }
    }


    my $use_item_count_labels = keys %households_by_inclusions > 1;

    my $summary_totals_label = new TotalCountLabel:: \@inclusion_labels, [@inclusion_counts{@inclusion_labels}];

    # Sort within each inclusion group
    @$_ = sort { $a->[0]{sort_by}  cmp $b->[0]{sort_by} } @$_ for values %households_by_inclusions;

    #print "DEBUG: sorted households_by_inclusions:\n", Dumper(\%households_by_inclusions) if $verbose > 4 && $debug;

    my $labels_per_page = $num_labels_across * $num_labels_down;

    # generate the lines to be put on each household's label, and
    # create inclusion labels
    my @labels;
    for my $inclusions ( sort { @{$households_by_inclusions{$b}} <=> @{$households_by_inclusions{$a}} } keys %households_by_inclusions ) {
        my @households = @{$households_by_inclusions{$inclusions}};
        for my $hi ( 0..$#households ) {
            my $hh = $households[$hi];
            if ($use_item_count_labels and $hi == 0 || @labels % $labels_per_page == 0) {
                my $first_label_on_page = (@labels+1) % $labels_per_page;
                if ( $first_label_on_page == 0 ) {
                    # No point putting a count-label in last position on page,
                    # where its count would be zero, so put the summary totals
                    # label here, or otherwise just leave it blank.
                    if ($summary_totals_label) {
                        push @labels, $summary_totals_label;
                        $summary_totals_label = undef;
                    }
                    else {
                        push @labels, one BlankLabel::;
                    }
                }
                my $last_label_on_page = ::min( @households-$hi+$first_label_on_page, $labels_per_page ) - 1;
                push @labels, new ItemCountLabel::
                                    $inclusions,
                                    scalar @labels,
                                    $first_label_on_page,
                                    $last_label_on_page;
            }
            my @hh = @$hh;
            if (@hh > 2) {
                # Rearrange the list to put the parent(s) first & second; leave the
                # second slot blank if there is only one parent.
                # (a) look for uid_of_children_under_16
                my @parents = grep { $_->uid_of_children_under_16 } @hh;
                my @children = grep { !$_->uid_of_children_under_16 } @hh;
                $#parents == 0 ||
                $#parents == 1 || warn sprintf "WARNING: group for %s has %u parents and %u children", $hh[0]->name, scalar @parents, scalar @children;
                $#parents = 1;
                for (@children) {
                    # Omit surnames on children
                    my $sn = $_->{family_name};
                    $_->{formatted} =~ s/\s*$sn$//,
                    $_->{family_name} = ' '
                }
                @hh = ( @parents, @children );
                # If more than one child, just use "and family"
                if (@hh > 3) {
                    # This sub has static scope, which is intentional
                    sub AndFamily::name {
                        my $r = shift;
                        $r->{composite_name} ||= state $f =
                            new string_with_components::
                                "family",
                                family_name => '',
                                given_name => '',
                                sort_by_surname => 'zz',
                                sort_by_givenname => 'zz';
                    }
                    state $and_family = bless {}, AndFamily::;
                    @hh = (@hh[0,1], $and_family);
                }
            }
            my @names = map { $_ && $_->name } @hh;
            for (1..$#names) {
                if ( $names[$_-1]->{family_name} eq $names[$_]->{family_name} ) {
                    $names[$_-1] = $names[$_-1]->{given_name};
                }
            }
            s/\s*\([^()]*\)\s*/ /g,
            s/ (?:ex|née*) .*// for @names;
            my $names = join ' & ', @names;
            my $postal_address = $hh[0]->postal_address;
            my $postcode = $postal_address->{postcode} || (UNIVERSAL::can($hh[0],'postcode') && $hh[0]->postcode || $hh[0]->{postcode})
                or warn sprintf "WARNING: missing postcode on %s at %s\n", $names[0], $postal_address;
            $postal_address =~ s/(.*\S)\s*\b$postcode\b/$1/ if $postcode;
            my @lines = grep {$_}
                            $names,
                            split /\s*\n/, $postal_address;
            push @labels, new HouseHoldLabel:: ($inclusions, $postcode, @lines);
        }
    }
    if ($summary_totals_label) {
        push @labels, $summary_totals_label;
        $summary_totals_label = undef;
    }

    #print "LABELS:\n", Dumper(\@labels) if $verbose > 4 && $debug;

    my $pq = new PDF_paginator:: ( page_size => [$page_size || ($page_width, $page_height)] );
    $page_width = $pq->{page_width};
    $page_height = $pq->{page_height};
    ($page_size) = (
        (                grep { my $ps = $paper_sizes->{$_}; near $page_width, $ps->[1], 200 and near $page_height, $ps->[0], 200 } keys %$paper_sizes ),
        ( map { $_.'R' } grep { my $ps = $paper_sizes->{$_}; near $page_width, $ps->[0], 200 and near $page_height, $ps->[1], 200 } keys %$paper_sizes ),
        ( sprintf "custom[%.2f × %.2f mm]", $page_height/mm, $page_width/mm ),
    );

    my $x_start = $label_left_margin + $page_left_margin;
    my $y_start = $label_top_margin  + $page_top_margin ;

    {
    my $printable_page_height = $page_height - $page_top_margin - $page_bottom_margin;
    my $printable_page_width  = $page_width  - $page_left_margin - $page_right_margin;

    $num_labels_across ||= $printable_page_width  / ($label_step_across || $label_width);
    $num_labels_down   ||= $printable_page_height / ($label_step_down   || $label_height);

    $label_step_across ||= $printable_page_width  / $num_labels_across || $label_height + $label_top_margin + $label_bottom_margin;
    $label_step_down   ||= $printable_page_height / $num_labels_down   || $label_width  + $label_left_margin + $label_right_margin;

    $label_height ||= $label_step_down   -  $label_top_margin - $label_bottom_margin;
    $label_width  ||= $label_step_across -  $label_left_margin - $label_right_margin;

    warn sprintf "First Page\n"
               . " page size: %.2fmm × %.2fmm (w×h) (%s)\n"
               . " printable: %.2fmm × %.2fmm (w×h)\n"
               . " labels/page: %d × %d (a×d)\n"
               . " label size: %.2fmm × %.2fmm (w×h)\n"
               . " label step: %.2fmm × %.2fmm (a×d)\n"
               . " offset: %.2fmm × %.2fmm (a×d)\n"
               ,
                $page_width/mm, $page_height/mm, $page_size,
                $printable_page_width/mm, $printable_page_height/mm,
                $num_labels_across, $num_labels_down,
                $label_width/mm, $label_height/mm,
                $label_step_across/mm, $label_step_down/mm,
                $x_start/mm, $y_start/mm,
        if $verbose;
    }

    my $printable_label_width  = $label_width  - $label_left_margin - $label_right_margin;
    my $printable_label_height = $label_height - $label_top_margin  - $label_bottom_margin;

    for my $r ( @labels ) {
        my $text = $pq->text;

        my $label_on_page = $pq->{page_item_num}++;

        my $col;
        my $row;
        if ($labels_ordered_in eq 'columns') {
            $row  = $label_on_page        % $num_labels_down;
            $col  = ($label_on_page-$row) / $num_labels_down;
        }
        else {
            $col  = $label_on_page        % $num_labels_across;
            $row  = ($label_on_page-$col) / $num_labels_across;
        }
        my $top  = $page_height - $y_start - $label_step_down   * $row;
        my $left =                $x_start + $label_step_across * $col;
        if ($use_cropbox) {
            my $right = $left + $printable_label_width;
            my $bottom = $top - $printable_label_height;
            $pq->pdf->cropbox($left, $bottom, $right, $top);
        }

        warn sprintf "Page %u label %u -> row %u/%u column %u/%u\n",
                    $pq->pages,
                    $label_on_page,
                    $row, $num_labels_across, $col, $num_labels_down if $verbose > 1;

        $r->draw_label($pq, $top, $left, $label_on_page);

        if ($label_on_page+1 >= $num_labels_across * $num_labels_down) {
            warn "Throwpage\n" if $verbose > 1;
            $pq->closepage;
        }
    }

    ( $out, my $out_name ) = _open_output $out, 1;
    print "Writing PDF to $out_name ($out)\n";
    print {$out} $pq->stringify;
    close $out or die "Error while writing to $out_name; $!\n";
}

################################################################################

    sub is_code($) { UNIVERSAL::isa($_[0], 'CODE') }
    sub is_hash($) { UNIVERSAL::isa($_[0], 'HASH') }
    sub is_regex($) { UNIVERSAL::isa($_[0], 'Regexp') }
    sub is_array($) { UNIVERSAL::isa($_[0], 'ARRAY') }
    sub is_array_of($$;$) {
        my ($array,$chk,$all) = @_;
        is_array($array) or return 0;
        my $c = $_[1] || return 1;
        for my $elem ( @$array ) {
          # defined $elem or next;
            $c->validate($elem)       or return 0 if UNIVERSAL::can($c, 'validate');
            $c->($elem)               or return 0 if is_code($c);
            $elem =~ $c               or return 0 if is_regex($c);
            UNIVERSAL::isa($elem, $c) or return 0;
        } continue {
            $_[2] || last;
        }
        return 1;
    }
    sub is_bool($)   { my $z = $_[0]; !ref $z && $z =~ m{^[01]$} }
    sub is_number($) { my $z = $_[0]; !ref $z && $z =~ m{^\-?\d+(?:\.\d+|)$} }

    sub yn($) { $_[0] ? 'yes' : 'no' }

    #
    # some simple manglers to provide recognizably distinct data
    #
    sub rot13($)   { $_[0] =~ tr{ A-M N-Z a-m n-z 0-4 5-9 }
                                { N-Z A-M n-z a-m 5-9 0-4 }r }
    sub phoneme($) { $_[0] =~ tr{ AE OU IY BP DT FV GK SZ LR MN CQ HJ WX ao eu iy bp dt fv gk sz lr mn cq hx jw 0123456789 }
                                { EA UO YI PB TD VF KG ZS RL NM QC JH XW oa ue yi pb td vf kg zs rl nm qc xh wj 9876543210 }r }
    sub bitflip($) { $_[0] =~ s{\w}{ pack "U", (ord($&)-2^1)+1 }er }
    sub backwards($) { scalar reverse $_[0] }

    #
    # render a list in columns, with pagination
    #
    sub render_columnated_list($$$$$;$$$) {
        my ( $pq, $render_one, $render_context, $rr, $items_across, $visible, $col, $top ) = @_;
        $col //= -1;    # start at top of first column
        $top //= 0;
        if (CHECK_ARGS) {
            @_ == 6 || @_ == 8 or ::croak "Wrong number of args";
            UNIVERSAL::isa($pq, PDF_paginator::) or ::croak "arg 1 is not a PDF_paginator";
            is_code $render_one or ::croak "arg 2 is not a sub";
            is_hash($render_context) or ::croak "arg 3 is not a hashref";
            is_array    $rr               or ::croak         "arg 4 is not an array";
          # is_array_of $rr, CSV::gmail:: or ::croak sprintf "arg 4 is not an array (of GMail records); ref=%s", @$rr ? ref $rr->[0] || '(void)' : '(empty)';
            is_number $items_across or ::croak "arg 5 is not a number (items-across)";
            is_bool $visible or ::croak "arg 6 is not a bool (visible)";
            is_number $col or ::croak "arg 7 is not a number (column number)";
            is_number $top or ::croak "arg 8 is not a number (top-position)";
        }
        my $printable_page_width  = $page_width  - $page_left_margin - $page_right_margin;
        my $column_step = ($printable_page_width + $book_intercolumn_margin)  / $items_across;
        my $column_width  = $column_step - $book_intercolumn_margin;

        # running estimate of worst-case item height
        my $height_limit = 0;
        my $zi = 0;
        for my $r (@$rr) {
            my $item_height = 0;

            # Compute exact item height in advance if either (a) not visible
            # (dimensions are all that are wanted), or (b) we're getting close
            # to the bottom of the column; otherwise use an estimate based on
            # 4× the current worst-case.
            my $item_height_estimate = $height_limit * 4;
            if ( $top - $item_height_estimate < $page_bottom_margin || ! $visible ) {
                $item_height =
                $item_height_estimate = $render_one->( $pq, $r, $render_context, $column_width, 0 ); # INVISIBLE: only compute size
            }

            # Move to next column if there isn't enough room left for whole item
            if ( $top - $item_height_estimate < $page_bottom_margin || $col < 0 ) {
                $top  = $page_height - $page_top_margin;
                ++$col;
                # Move to next page if this page is full
                if ($col >= $items_across) {
                    warn "Throwpage\n" if $verbose > 1;
                    $pq->closepage if $visible;
                    $col = 0;
                }
            }
            if ($visible) {
                my $text = $pq->text;
                $text->fillcolor('black');
                my $left = $page_left_margin + $column_step * $col;
                (my $item_width, $item_height) = $render_one->( $pq, $r, $render_context, $column_width, 1, $top, $left ); # VISIBLE
                warn sprintf "COLUMNATION: item #%d ↑%.2fmm →%.2fmm ↕%.2fmm ↔%.2fmm\n", $zi++, $top/mm, $left/mm, $item_height/mm, $item_width/mm if $verbose > 2;
            }
            $top -= $item_height;
            $height_limit >= $item_height or $height_limit = $item_height;
        }
        return $col, $top;
    }

    #
    # sort and render a list, possibly in multiple orders
    #
    sub render_sorted_columnated_list($$$$$;$$$) {
        my ( $pq, $render_one, $render_context, $rr, $items_across, $visible, $col, $top ) = @_;
        $visible //= 1;
        if (CHECK_ARGS) {
            @_ == 6 or @_ == 8 or ::croak "Wrong number of args";
            UNIVERSAL::isa($pq, PDF_paginator::) or ::croak "arg 1 is not a PDF_paginator";
            is_code $render_one or ::croak "arg 2 is not a sub";
            is_hash($render_context) or ::croak "arg 3 is not a hashref";
            is_array_of($rr, CSV::gmail::) or ::croak "arg 4 is not an array (of GMail records)";
            is_number $items_across or ::croak "arg 5 is not a number";
            is_bool $visible or ::croak "arg 6 is not a flag (visible)";
            is_number $col or ::croak "arg 7 is not a number (column number)" if @_ > 6;
            is_number $top or ::croak "arg 8 is not a number (top-position)" if @_ > 6;
        }
        if ($book_sort_by_surname) {
            @$rr = sort_by_surname @$rr;
            $render_context->{ORDER} = 'surname';
            ($col, $top) = render_columnated_list( $pq, $render_one, $render_context, $rr, $items_across, $visible, $col, $top );
        }
        if ($book_sort_by_givenname) {
            @$rr = sort_by_givenname @$rr;
            $render_context->{ORDER} = 'given_name';
            ($col, $top) = render_columnated_list( $pq, $render_one, $render_context, $rr, $items_across, $visible, $col, $top );
        }
        delete $render_context->{ORDER};
        return $col, $top;
    }

    my $mtg_abbrev_len = 5;

    #
    # You get listed in MM-elsewhere if
    #  1, you're tagged for it; or
    #  2, you're a member of the MM but *not* in any WG listing within that MM (including not MM-overseas)
    #
    sub elsewhere_filter($$) {
        my ($rrr, $mm) = @_;
        $rrr or return;
        return [ grep { $_->gtags( qr/^listing[- ]+$mm[- ]+elsewhere/ )
                   || ! $_->gtags( qr/^listing[- ]+$mm/ )
                     && $_->gtags( qr/^member[- ]+$mm/ )
                    } @$rrr ];
    }

use quaker_info qw( %wg_abbrev @mm_order %mm_titles @wg_order %skip_mm_listing %skip_wg_listing );

sub generate_book($$;$) {
    my $out = shift;
    my $rr0 = shift;
    my $in_name = shift || '(stdin)';

#   use_preset 'book';

    my $rev_ymd;
    if ($in_name =~ /-((20\d\d)([01]\d)([0-3]\d))\./) {
        $rev_ymd = $1
    } else {
        $rev_ymd = strftime '%Y%m%d', localtime $^T;
        $rev_ymd =~ /^((20\d\d)([01]\d)([0-3]\d))$/;
    }
    my ($rev_year, $rev_month, $rev_day) = ($2,$3,$4);
    my $rev_dmmy = strftime "%d%b%Y", (0)x3, $rev_day, $rev_month-1, $rev_year-1900;

    my $copyright = sprintf "Compilation copyright ©%u The Religious Society of Friends Aotearoa New Zealand, all rights reserved. For personal use only. Revised %s", $rev_year, $rev_dmmy;

    my $rr = suppress_unwanted_records $rr0;
    @$rr = grep { $_->gtags( 'members', 'attenders', 'child', 'inactive', 'meeting' ) } @$rr;

    my %by_mm;
    my %by_wg;
    for my $r (@$rr) {
        if ( my @meetings = $r->gtags( qr/^listing[- ]+((?:$mm_keys_re|YF)\b.*)/ ) ) {
            @meetings = uniq @meetings if @meetings > 1;
            for my $m (@meetings) {
                push @{$by_wg{$m}}, $r;
            }
        }
        elsif ( ! $r->gtags( 'meeting' ) ) {
            push @{$by_wg{'NO - not in any worship group'}}, $r;
        }
        if ( my @meetings = $r->gtags( qr/^(?:listing|member)[- ]+($mm_keys_re)/ ) ) {
            @meetings = uniq @meetings if @meetings > 1;
            for my $m (@meetings) {
                push @{$by_mm{$m}}, $r;
            }
        }
        elsif ( ! $r->gtags( 'meeting' ) ) {
            push @{$by_mm{'NO - not in any meeting'}}, $r;
        }
    }
    {
        # Find meeting tags, make sure they're in the "@wg_order" list
        my @wg = keys %by_wg;
        my %w1 = map { ( $_ => 1 ) } @wg;
        my %w2 = map { ( $_ => 1 ) } @wg_order;
        delete @w1{ @wg_order };
        delete @w2{ @wg };
        ! %w1 or die sprintf "WG_ORDER is missing %s\n", join ',', sort keys %w1;
        ! %w2 or warn sprintf "WG_ORDER has excess %s\n", join ',', sort keys %w2;
    }


    my $pq = new PDF_paginator:: ( page_size => [$page_size || ($page_width, $page_height)] );

    # if pagesize was given as eg "A5", convert that back to actual dimensions
    $page_width = $pq->{page_width};
    $page_height = $pq->{page_height};

    my $printable_page_height = $page_height - $page_top_margin - $page_bottom_margin;
    my $printable_page_width  = $page_width  - $page_left_margin - $page_right_margin;
    my $fontname = $book_fontname;
    my $email_fontname = $book_email_fontname;
    my $fontsize = $book_fontsize;
    my $small_fontsize = $book_fontsize; #*2/3;
    my $lineheight = $fontsize * ::min 1, $line_spacing/(1+$extra_para_spacing);

    warn sprintf "Pagination info\n"
               . "page size: %.2fmm × %.2fmm (%s)\n"
               . "printable page size: %.2fmm × %.2fmm\n"
               ,
                $page_width/mm, $page_height/mm, $page_size,
                $printable_page_width/mm, $printable_page_height/mm,
        if $verbose;

    my $TB   = $pq->TB;
    my $TBI  = $pq->TBI;
    my $TBIU = $pq->TBIU;
    my $TBU  = $pq->TBU;
    my $TI   = $pq->TI;
    my $TIU  = $pq->TIU;
    my $TU   = $pq->TU;
    my $TN   = $pq->TN;

    my $render_column_heading = sub {
        my ( $pq, $r, $render_context, $column_width, $visible, $top, $left ) = @_;
        if (CHECK_ARGS) {
            if ($visible) {
                @_ == 7 or ::croak sprintf "Wrong number of args; expected %d with 'visible', got %d", 7, 0+@_;
            } else {
                @_ == 5 or ::croak sprintf "Wrong number of args; expected %d with 'invisible', got %d", 5, 0+@_;
            }
            UNIVERSAL::isa($pq, PDF_paginator::) or ::croak "arg 1 is not a PDF_paginator";
            ! defined $r or ::croak "arg 2 should be undef but is not\n";
            is_hash($render_context) or ::croak "arg 3 is not a hashref";
            is_number $column_width or ::croak "arg 4 is not a number (item-width)" if @_ >= 4;
            is_bool $visible or ::croak "arg 5 is not a flag (visible)" if @_ >= 5;
            is_number $top or ::croak "arg 6 is not a number (top-position)" if $visible;
            is_number $left or ::croak "arg 7 is not a number (left-position)" if $visible;
        }
        if ($verbose) {
            if ($visible) {
                warn sprintf "RENDER heading ↔%.2fmm →%.2fmm ↑%.2fmm\n", $column_width/mm, $left/mm, $top/mm
                    if $verbose > 2;
            }
            else {
                warn sprintf "SIZING heading ↔%.2fmm\n", $column_width/mm
                    if $verbose > 2;
            }
        }

        my $heading_text = $render_context->{heading} or return 0, 0;
        $heading_text = $TB . $heading_text . $TN if $render_context->{heading_bold};

        my $heading_fontname = $render_context->{heading_font} || $fontname;
        my $heading_fontsize = $render_context->{heading_size} || $fontsize;
        my $heading_line_spacing = $render_context->{heading_spacing} || $line_spacing;
        my $text = $pq->text;
        my $item_height;

        if ( $visible ) {
            (undef, $item_height) = $pq->text_flow($heading_fontname, $heading_fontsize, $heading_line_spacing, $heading_text, $column_width, $top, $left);
        } else {
            (undef, $item_height) = $pq->text_size($heading_fontname, $heading_fontsize, $heading_line_spacing, $heading_text, $column_width);
        }
        warn sprintf "HEADING: ↑%.2fmm →%.2fmm ↕%.2fmm ↔%.2fmm\n", $top/mm, $left/mm, $item_height/mm, $column_width/mm if $verbose > 2;
        return $column_width, $item_height;
    };

    # Copyright
    push @{$pq->{upon_end_page}}, sub {
            my ($pq, $pagenum) = @_;
            my $right_page = $pagenum % 2;
            $pq->text_at($copyright, { fn => $book_fontname, fs => $book_pagenumber_fontsize, y => $page_height-$page_top_margin/2, x => $page_width/2, halign => 1, valign => 1, italic => 1, });
        };

    # Page numbering
    if ($use_page_numbers) {
        # Number each page
        push @{$pq->{upon_end_page}}, sub {
            my ($pq, $pagenum) = @_;
            my $right_page = $pagenum % 2;
            $pq->text_at($pagenum, { fn => $book_fontname, fs => $book_pagenumber_fontsize, y => $page_bottom_margin/2, x => $page_width/2, halign => 1, valign => 1, italic => 1, });
        };
    }

    # Margin stamping
    push @{$pq->{upon_end_page}}, sub {
            my ($pq, $pagenum) = @_;
            my $page_data = $pq->{pagedata} or return;
            my $margin_notes = $page_data->{margin_notes_list} || $page_data->{margin_notes} or return;
            my $right_page = $pagenum % 2;
            my $mm_lh = $book_margin_fontsize*$line_spacing;
            my $top =  $page_height - $page_top_margin - $mm_lh;
            my $left = $right_page ? $page_width-$page_right_margin/2
                                   : $page_left_margin/2;
            if (ref $margin_notes) {
                $margin_notes = $right_page ? join ", ",         @$margin_notes
                                            : join ", ", reverse @$margin_notes;
            }
            $pq->text_at($margin_notes, {   fn => $fontname,
                                            fs => $book_margin_fontsize,
                                            y => $top,
                                            x => $left,
                                            r => $right_page ? 3 : 1,
                                            valign => 0,
                                            halign => 1,
                                        } );
        };

    # Render the first letter of the surname of:
    #   * the FIRST record in the top-left corner of a left page,
    #   * the LAST record in the top-right corner of a right page
    # Note that this will produce gibberish if you have (parts of) more than one list on a page
    my $first_or_last_on_page = sub {
        my ($pq, $pagenum) = @_;
        my $page_data = $pq->{pagedata} or return;
        my $right_page = $pagenum % 2;
        my $mm_lh = $book_margin_fontsize*$line_spacing;
        my $top = $page_height - $page_top_margin + $mm_lh;
        my $left;
        my $from_letter = $page_data->{first}{initial};
        my $to_letter = $page_data->{last}{initial};
        my $margin_notes = join '-', $from_letter, $to_letter eq $from_letter ? () : $to_letter;
        if ($right_page) {
           #$margin_notes = $page_data->{last}{initial} || '-' ; #'R'.$pq->pagenum;
            $left = $page_width-$page_right_margin/2;
        } else {
           #$margin_notes = $page_data->{first}{initial} || '-' ; #'L'.$pq->pagenum;
            $left = $page_left_margin/2;
        }
        $pq->text_at($margin_notes, { fn => $fontname, fs => $book_margin_fontsize, y => $top, x => $left, halign => 1, });
    };

    my %detail_widths = (
        phone   => 0.20,
        name    => 0.30,
        details => 0.50, );

    my @detail_order = $book_phones_first ? qw( phone name details )
                                          : qw( name phone details );

    my @detail_offsets = (0, @detail_widths{@detail_order[0..$#detail_order-1]});
    $detail_offsets[$_] += $detail_offsets[$_-1] for 1..$#detail_offsets;

    my %detail_offsets; @detail_offsets{@detail_order} = @detail_offsets;

    #my %detail_order = map { ( $detail_order[$_] => $_ ) } 0..$#detail_order;

    my $render_person_details = sub {
        my ( $pq, $r, $render_context, $column_width, $visible, $top, $left ) = @_;
        if (CHECK_ARGS) {
            if ($visible) {
                @_ == 7 or ::croak sprintf "Wrong number of args; expected %d with 'visible', got %d", 7, 0+@_;
            } else {
                @_ == 5 or ::croak sprintf "Wrong number of args; expected %d with 'invisible', got %d", 5, 0+@_;
            }
            UNIVERSAL::isa($pq, PDF_paginator::) or ::croak "arg 1 is not a PDF_paginator ref";
            UNIVERSAL::isa($r, CSV::gmail::) or ::croak "arg 2 is not a gmail record";
            is_hash($render_context) or ::croak "arg 3 is not a hashref";
            is_number $column_width or ::croak "arg 4 is not a number (item-width)" if @_ >= 4;
            is_bool $visible or ::croak "arg 5 is not a flag (visible)" if @_ >= 5;
            is_number $top or ::croak "arg 6 is not a number (top-position)" if $visible;
            is_number $left or ::croak "arg 7 is not a number (left-position)" if $visible;
        }

        my $inactive = $r->gtags('inactive','child');
        my $ismember = $r->gtags('members');
        my $name = $r->name;
        my $family_name = $name->{family_name};
        $name = "$name";
        $name =~ s/\([^()]*\)//g;

        my $page_data = $pq->{pagedata} ||= {};

        # add to margin notes
        if ( my $margin_note = $render_context->{margin_note} ) {
            if ( ! $page_data->{seen_margin_note}{$margin_note}++ ) {
                my $mn = $page_data->{margin_notes_list} ||= [];
                push @$mn, $margin_note;
            }
        }

        my $order_name = $render_context->{ORDER} eq 'surname' ? $family_name : $name;
        my $order_initial = substr $order_name, 0, 1;

        # record name info of last entry on page
        $page_data->{last} = {  initial     => $order_initial,
                                oname       => $order_name,
                                full_name   => $name,
                                family_name => $family_name, };
        # record name info of first entry on page
        $page_data->{first} ||= $page_data->{last};

        if ($name) {
            my $N = $ismember ? $TU  : $inactive ? $TI  : $TN;
            my $B = $ismember ? $TBU : $inactive ? $TBI : $TB;
            $name =~ s/\b$family_name\z/$B$&$N/ if $family_name;
            $name = $N.$name.$TN;
        }

        my @phones = map { localize_phone $_ } $r->listed_phone;
        my $emails = join " ", uniq $r->listed_email;
        my $phones = join "\n", map { s/(?<=\d) (?=\d)/\N{NBSP}/gr } @phones;
        my $addresses = join "\n", ( map { s/\n/, /gr } $r->listed_address );

        my @subcolumn_offset = map { $_ * ($column_width + $book_interdetail_spacing) } @detail_offsets{qw( phone name details )}, 1;
        my @subcolumn_width  = map { $_ * ($column_width + $book_interdetail_spacing) - $book_interdetail_spacing } @detail_widths{qw( phone name details )};
        my ($h1,$h2,$h3) = (0) x 3;
        if ($visible) {
            (undef, $h1) = $pq->text_flow($fontname, $fontsize, $line_spacing, $phones,    $subcolumn_width[0], $top, $left + $subcolumn_offset[0]);
            (undef, $h2) = $pq->text_flow($fontname, $fontsize, $line_spacing, $name,      $subcolumn_width[1], $top, $left + $subcolumn_offset[1]);
            if ($addresses) {
                (undef, my $h4) = $pq->text_flow($fontname, $fontsize, $line_spacing, $addresses, $subcolumn_width[2], $top, $left + $subcolumn_offset[2]);
                $h3 += $h4;
            }
            if ($emails) {
                (undef, my $h4) = $pq->text_flow($email_fontname, $fontsize, $line_spacing, $emails,  $subcolumn_width[2], $top-$h3, $left + $subcolumn_offset[2]);
                $h3 += $h4;
            }
        }
        else {
            (undef, $h1) = $pq->text_size($fontname, $fontsize, $line_spacing, $phones,    $subcolumn_width[0]);
            (undef, $h2) = $pq->text_size($fontname, $fontsize, $line_spacing, $name,      $subcolumn_width[1]);
            if ($addresses) {
                (undef, my $h4) = $pq->text_size($fontname, $fontsize, $line_spacing, $addresses, $subcolumn_width[2]);
                $h3 += $h4;
            }
            if ($emails) {
                (undef, my $h4) = $pq->text_size($email_fontname, $fontsize, $line_spacing, $emails, $subcolumn_width[2]);
                $h3 += $h4;
            }
        }
        my $item_height = $lineheight*$extra_para_spacing + ::max $h1, $h2, $h3;
        if ($verbose) {
            my $fmt = $visible ? "RENDER details ↕%.2fmm=%.2f*%.2f*(%.2f,%.2f,%.2f) ↔%.2fmm ↑%.2fmm →%.2fmm"
                               : "SIZING details ↕%.2fmm=%.2f*%.2f*(%.2f,%.2f,%.2f) ↔%.2fmm";
            warn sprintf "$fmt\n", $item_height/mm, ($lineheight/mm, $extra_para_spacing, $h1, $h2, $h3),
                                    $column_width/mm,
                                    ($top//0)/mm, ($left//0)/mm
                if $verbose > 2;
        }
        # create pagenum cross references for later use by indexing
        push @{$r->{_page_xrefs}}, $pq->pagenum if $visible;
        return $column_width, $item_height;
    };

    my $render_person_index = sub {
        my ( $pq, $r, $render_context, $column_width, $visible, $top, $left ) = @_;
        if (CHECK_ARGS) {
            if ($visible) {
                @_ == 7 or ::croak sprintf "Wrong number of args; expected %d with 'visible', got %d", 7, 0+@_;
            } else {
                @_ == 5 or ::croak sprintf "Wrong number of args; expected %d with 'invisible', got %d", 5, 0+@_;
            }
            UNIVERSAL::isa($pq, PDF_paginator::) or ::croak "arg 1 is not a PDF_paginator ref";
            UNIVERSAL::isa($r, CSV::gmail::) or ::croak "arg 2 is not a gmail record";
            is_hash($render_context) or ::croak "arg 3 is not a hashref";
            is_number $column_width or ::croak "arg 4 is not a number (item-width)" if @_ >= 4;
            is_bool $visible or ::croak "arg 5 is not a flag (visible)" if @_ >= 5;
            is_number $top or ::croak "arg 6 is not a number (top-position)" if $visible;
            is_number $left or ::croak "arg 7 is not a number (left-position)" if $visible;
        }

        # retrieve pagenum cross references
        my @page_xrefs;
        if ( $use_page_numbers ) {
            @page_xrefs = @{$r->{_page_xrefs} ||= []};
            if (@page_xrefs == 1) {
                @page_xrefs = sprintf "p.%u", @page_xrefs;
            } elsif ( @page_xrefs > 1 ) {
                @page_xrefs = sprintf "pp.%s", join ",\N{ZWNJ}", @page_xrefs;
            }
            $_ = $TI . $_ . $TN for @page_xrefs;
        }

        if ($verbose) {
            if ($visible) {
                warn sprintf "RENDER index ↔%.2fmm →%.2fmm ↑%.2fmm\n", $column_width/mm, $left/mm, $top/mm
                    if $verbose > 2;
            }
            else {
                warn sprintf "SIZING index ↔%.2fmm\n", $column_width/mm
                    if $verbose > 2;
            }
        }

        my $text = $pq->text;
        my $width = 0;

        my $inactive = $r->gtags('inactive','child');
        my $ismember = $r->gtags('members');
        my $name = $r->name;
        my $family_name = $name->{family_name};
        $name = "$name";
        $name =~ s/\([^()]*\)//g;

        my $page_data = $pq->{pagedata} ||= {};

        # add to margin notes
        if ( my $margin_note = $render_context->{margin_note} ) {
            if ( ! $page_data->{seen_margin_note}{$margin_note}++ ) {
                my $mn = $page_data->{margin_notes_list} ||= [];
                push @$mn, $margin_note;
            }
        }

        my $order_name = $render_context->{ORDER} eq 'surname' ? $family_name : $name;
        my $order_initial = substr $order_name, 0, 1;

        # record name info of last entry on page
        $page_data->{last} = {  initial     => $order_initial,
                                oname       => $order_name,
                                full_name   => $name,
                                family_name => $family_name, };
        # record name info of first entry on page
        $page_data->{first} ||= $page_data->{last};

        if ($name) {
            my $N = $ismember ? $TU  : $inactive ? $TI  : $TN;
            my $B = $ismember ? $TBU : $inactive ? $TBI : $TB;
            $name =~ s/\b$family_name\z/$B$&$N/ if $family_name;
            $name = $N.$name.$TN;
        }

        my @listings = map { $wg_abbrev{$_} && $wg_abbrev{$_}[$mtg_abbrev_len] || $_ }
                           $r->gtags(qr/^listing[- ]+(\w\w\w?\b.*)/);
        my @memberships = $r->gtags(qr/^member[- ]+(\w\w\w?)\b/);

        my @phones = map { localize_phone $_ } $r->listed_phone;
        my ($w1, $h1, $c1, $t1);
        if ( $visible ) {
            ($w1, $h1, $c1, $t1) = $pq->text_flow($fontname, $fontsize, $line_spacing, $name, $column_width, $top, $left);
        } else {
            ($w1, $h1, $c1, $t1) = $pq->text_size($fontname, $fontsize, $line_spacing, $name, $column_width);
        }
        for my $s (@page_xrefs, @memberships, @listings, @phones) {
            my ($w, $h) = $pq->text_size($fontname, $small_fontsize, $line_spacing, $s);
            if ($t1 < $h1 && $c1 + $book_interdetail_spacing + $w > $column_width) {
                # Skip to next blank line if it won't fit to the right
                $c1 = 0;
                $t1 = $h1;
            }
            $pq->text_flow($fontname, $small_fontsize, $line_spacing, $s, $w, $top-$t1, $left+$column_width-$w)
                if $visible;
            $t1 += $h;
        }

        my $item_height = max $h1, $t1;
        warn sprintf "ITEM: ↑%.2fmm →%.2fmm ↕%.2fmm=max((h1=%.2f),(t1=%.2f)) ↔%.2fmm\n", $top/mm, $left/mm, $item_height/mm, $h1/mm, $t1/mm, $column_width/mm if $verbose > 2;
        return $column_width, $item_height;
    };

    #@$rr = grep { ! $_->gtags( qr/^meeting/ ) } @$rr;       # only humans in main listing
    if ($do_book_listing_all) {
        warn "doing book LISTING - all\n" if $verbose;
        # Margin name index letters
        my %render_context = (  margin_note     => "(full alphanetical listing)",
                                heading         => "Everyone",
                                heading_bold    => 1,
                                heading_size    => $fontsize * PHI,
                             );
        push @{$pq->{upon_end_page}}, $first_or_last_on_page;   # need closepage after each group with this
        my ($col, $top) = render_columnated_list    ($pq, $render_column_heading, \%render_context, [undef], 1, 1, undef, undef);
        ($col, $top) = render_sorted_columnated_list($pq, $render_person_details, \%render_context, $rr, 1, 1, $col, $top);
        $pq->closepage;
        pop @{$pq->{upon_end_page}};
    }

    if ($do_book_listing_by_mm) {
        warn "doing book LISTING - by MM\n" if $verbose;
        push @{$pq->{upon_end_page}}, $first_or_last_on_page;   # need closepage after each group with this
        for my $mm ( @mm_order ) {
            $skip_mm_listing{$mm} and next;
            my $rrr = $by_mm{$mm} or next;
           #my $rrr = [grep { $_->gtags( qr/^(?:listing|member)[- ]+$mm/ ) } @$rr];
            warn sprintf "doing book LISTING - for MM '%s'\n", $mm if $verbose;
            my $heading = $mm_titles{$mm};
            my %render_context = (  margin_note     => $heading,
                                    heading         => $heading,
                                    heading_bold    => 1,
                                    heading_size    => $fontsize * PHI,
                                 );
            $pq->closepage;
            my ($col, $top) = render_columnated_list    ($pq, $render_column_heading, \%render_context, [undef], 1, 1, undef, undef);
            ($col, $top) = render_sorted_columnated_list($pq, $render_person_details, \%render_context, $rrr, 1, 1, $col, $top);
        }
        $pq->closepage;
        pop @{$pq->{upon_end_page}};
    }

    if ($do_book_listing_by_wg) {
        warn "doing book LISTING - by WG\n" if $verbose;
        my $col;
        my $top = 0;
        for my $wg ( @wg_order ) {
            $skip_wg_listing{$wg} and next;
            my ($mm, $heading) = split /[- ]+/, $wg, 2;
            my $margin_note = $heading;

            my $rrr;
            if ( $heading eq 'elsewhere' ) {
                $rrr = elsewhere_filter $by_mm{$mm}, $mm or next;
                $heading = sprintf "%s, in other parts of NZ", $mm_titles{$mm};
                $margin_note = sprintf "%s MM in NZ", $mm;
            } else {
                $rrr = $by_wg{$wg} or next;
                if ( $heading eq 'overseas' ) {
                    $heading = sprintf "%s, overseas", $mm_titles{$mm};
                    $margin_note = sprintf "%s MM overseas", $mm;
                } elsif ($mm eq 'YF') {
                    $heading = join ' ', 'Young Friends', $heading || ();
                }
            }

            warn sprintf "doing book LISTING - for WG '%s'\n", $heading if $verbose;

            my %render_context = (  margin_note     => $margin_note,
                                    heading         => $heading,
                                    heading_bold    => 1,
                                    heading_size    => $fontsize * PHI,
                                 );
            if ( $top < $fontsize*$line_spacing*(6+@$rrr/2) ) { $top = 0 }    # skip to next column if not enough room for 6 lines or if the following list is "large"
            else { $top -= $fontsize*$line_spacing*2 }              # leave 2 blank lines between end of previous group and heading for next group
            ($col, $top) = render_columnated_list       ($pq, $render_column_heading, \%render_context, [undef], 1, 1, $col, $top);
            ($col, $top) = render_sorted_columnated_list($pq, $render_person_details, \%render_context, $rrr, 1, 1, $col, $top);

          # $pq->closepage; $col = -1; $top = 0;
        }
        $pq->closepage;
    }

    if ($do_book_index_all) {
        warn "doing book INDEX - all\n" if $verbose;
        # Margin name index letters
        push @{$pq->{upon_end_page}}, $first_or_last_on_page;   # need closepage after each group with this
        my %render_context = (  margin_note     => "full alphanetical index",
                                heading         => "Everyone",
                                heading_bold    => 1,
                                heading_size    => $fontsize * PHI,
                             );
        my ($col, $top) = render_columnated_list    ($pq, $render_column_heading, \%render_context, [undef], 1, 1, undef, undef);
        ($col, $top) = render_sorted_columnated_list($pq, $render_person_index, \%render_context, $rr, 3, 1, $col, $top);
        $pq->closepage;
        pop @{$pq->{upon_end_page}};
    }

    if ($do_book_index_by_mm) {
        warn "doing book INDEX - by MM\n" if $verbose;
        push @{$pq->{upon_end_page}}, $first_or_last_on_page;   # need closepage after each group with this
        for my $mm ( @mm_order ) {
            $skip_mm_listing{$mm} and next;
            warn sprintf "doing book INDEX - for MM '%s'\n", $mm if $verbose;
            my $rrr = $by_mm{$mm} or next;
            $pq->closepage;
            my $h = $mm_titles{$mm};
            my %render_context = (  margin_note     => $h,
                                    heading         => $h,
                                    heading_bold    => 1,
                                    heading_size    => $fontsize * PHI,
                                 );
            my ($col, $top) = render_columnated_list    ($pq, $render_column_heading, \%render_context, [undef], 1, 1, undef, undef);
            ($col, $top) = render_sorted_columnated_list($pq, $render_person_index, \%render_context, $rrr, 3, 1, $col, $top);
            $pq->closepage;
        }
        pop @{$pq->{upon_end_page}};
    }

    if ($do_book_index_by_wg) {
        warn "doing book INDEX - by WG\n" if $verbose;
        my $col;
        my $top = 0;
        for my $wg ( @wg_order ) {
            $skip_wg_listing{$wg} and next;
            my ($mm, $heading) = split /[- ]+/, $wg, 2;
            my $margin_note = $heading;

            my $rrr;
            if ( $heading eq 'elsewhere' ) {
                $rrr = elsewhere_filter $by_mm{$mm}, $mm or next;
                $heading = sprintf "%s, in other parts of NZ", $mm_titles{$mm};
                $margin_note = sprintf "%s MM in NZ", $mm;
            } else {
                $rrr = $by_wg{$wg} or next;
                if ( $heading eq 'overseas' ) {
                    $heading = sprintf "%s, overseas", $mm_titles{$mm};
                    $margin_note = sprintf "%s MM overseas", $mm;
                } elsif ($mm eq 'YF') {
                    $heading = join ' ', 'Young Friends', $heading || ();
                }
            }

            warn sprintf "doing book INDEX - for WG '%s'\n", $heading if $verbose;

            my %render_context = (  margin_note     => $margin_note,
                                    heading         => $heading,
                                    heading_bold    => 1,
                                    heading_size    => $fontsize * PHI,
                                 );
            if ( $top < $fontsize*$line_spacing*(6+@$rrr/2) ) { $top = 0 }    # skip to next column if not enough room for 6 lines or if the following list is "large"
            else { $top -= $fontsize*$line_spacing*2 }              # leave 2 blank lines between end of previous group and heading for next group
            ($col, $top) = render_columnated_list       ($pq, $render_column_heading, \%render_context, [undef], 3, 1, $col, $top);
            ($col, $top) = render_sorted_columnated_list($pq, $render_person_index, \%render_context, $rrr, 3, 1, $col, $top);

          # $pq->closepage; $col = -1; $top = 0;
        }
        $pq->closepage;
    }

    $pq->closepage;
    delete $pq->{upon_end_page};

    ( $out, my $out_name ) = _open_output $out, 1;
    print "Writing PDF to $out_name ($out)\n";
    print {$out} $pq->stringify;
    close $out or die "Error while writing to $out_name; $!\n";
}
};

sub generate_test($) {
    my $out = shift;

    my $pq = new PDF_paginator:: ( page_size => [$page_size || ($page_width, $page_height)] );

    # if pagesize was given as eg "A5", convert that back to actual dimensions
    $page_width = $pq->{page_width};
    $page_height = $pq->{page_height};

    my $printable_page_height = $page_height - $page_top_margin - $page_bottom_margin;
    my $printable_page_width  = $page_width  - $page_left_margin - $page_right_margin;
    my $fontname = $book_fontname;
    my $fontsize = $book_fontsize;
    my $lineheight = $fontsize * ::min 1, $line_spacing/(1+$extra_para_spacing);

    warn sprintf "Pagination info\n"
               . "page size: %.2fmm × %.2fmm (%s)\n"
               . "printable page size: %.2fmm × %.2fmm\n"
               ,
                $page_width/mm, $page_height/mm, $page_size,
                $printable_page_width/mm, $printable_page_height/mm,
        if $verbose;

    for my $v ( 0..2 ) {
        for my $h ( 0..2 ) {
            for my $r ( 0..3 ) {
                $pq->text_at( sprintf('test text r=%s h=%s v=%s', $r, $h, $v),
                              x => $page_width/2,
                              y => $page_height/2,
                              fn => $book_fontname,
                              fs => 72*pt,
                              r => $r+0.5,
                              halign => $h,
                              valign => $v,
                            );
            }
    $pq->closepage;
        }
    }
    $pq->closepage;
    delete $pq->{upon_end_page};

    ( $out, my $out_name ) = _open_output $out, 1;
    print "Writing PDF to $out_name ($out)\n";
    print {$out} $pq->stringify;
    close $out or die "Error while writing to $out_name; $!\n";
}

################################################################################

#
# Sanity-check command-line args
#

$do_test || $do_book || $do_diff || $do_diffable_dump || $do_labels || $do_qndb_map or die "Need at least one of: --book-* --labels --diff --dump --qndb-map\n";

#
# Actual work...
#

if ($do_test) {
    my $o = $output_name || ( $force_overwrite = -1,    # it's only a test file, after all;
                              'test.pdf' );
    generate_test( $o );
}
elsif ($do_diff) {
    $do_book || $do_diffable_dump || $do_labels || $do_qndb_map and die "Can't combine --diff with anything else\n";

    my $f1 = shift @ARGV;
    my $f2 = shift @ARGV || '-';
    @ARGV == 0 or die "Need two files (or one file and stdin) with --diff\n";
    my $rr1 = parse_file $f1;
    my $rr2 = parse_file $f2;
    generate_diff( $output_name, $rr1, $f1, $rr2, $f2 );
}
else {
    if (!@ARGV) {
        @ARGV = '-';
        $output_name ||= '-';
    }
    ! $output_name or
    $do_book + $do_labels + $do_diffable_dump + $do_qndb_map == 1 or die "Only one function allowed with --output\n";

    for my $a (@ARGV) {
        my $rr = parse_file $a;
    #   if ($debug) {
    #       print Dumper($rr);
    #   }
        if ($do_book) {
            # Force overwrite if the output filename is related to (but not the same as) the input filename
            my $o = $output_name || ( $force_overwrite ||= -1, $a =~ s/(?:\.\w+|)$/-book.pdf/r );
            $o ne '-' && $o eq $a && $force_overwrite < 1 && die "Can't overwrite input file as output file\n";
            generate_book( $o, $rr, $a );
        }
        if ($do_labels) {
            # extra sanity-check
            $labels_ordered_in eq 'columns' || $labels_ordered_in eq 'rows' || die "Label ordering must be 'rows' or 'columns'\n";
            # Force overwrite if the output filename is related to (but not the same as) the input filename
            my $o = $output_name || ( $force_overwrite ||= -1, $a =~ s/(?:\.\w+|)$/\.pdf/r );
            $o ne '-' && $o eq $a && $force_overwrite < 1 && die "Can't overwrite input file as output file\n";
            generate_labels( $o, $rr, $a );
        }
        if ($do_diffable_dump) {
            my $o = $output_name || '-';
            diffably_dump_records( $o, $rr, $a );
        }
        if ($do_qndb_map) {
            # Force overwrite if the output filename is related to (but not the same as) the input filename
            my $o = $output_name || ( $force_overwrite ||= -1, $a =~ s/(?:\.\w+|)$/-qdb.csv/r );
            $o ne '-' && $o eq $a && $force_overwrite < 1 && die "Can't overwrite input file as output file\n";
            generate_qndb_map( $o, $rr, $a );
        }
    }
}

1;

__END__

Set the global mediabox                     Set the global cropbox                      Set the global bleedbox                     Set the global trimbox                      Set the global artbox

->mediabox($name)                           ->cropbox($name)                            ->bleedbox($name)                           ->trimbox($name)                            ->artbox($name)
->mediabox($width, $height)                 ->cropbox($width, $height)                  ->bleedbox($width, $height)                 ->trimbox($width, $height)                  ->artbox($width, $height)
->mediabox($left, $bottom, $right, $top)    ->cropbox($left, $bottom, $right, $top)     ->bleedbox($left, $bottom, $right, $top)    ->trimbox($left, $bottom, $right, $top)     ->artbox($left, $bottom, $right, $top)

Examples:

   $pdf->mediabox('A4');
   $pdf->mediabox(595, 842);
   $pdf->mediabox(0, 0, 595, 842);

