#!/usr/bin/perl

use 5.010;
use strict;
use warnings;
use utf8;

use FindBin;
use lib "$FindBin::Bin", "$FindBin::Bin/../lib";

use Fcntl qw( SEEK_CUR SEEK_SET );
use POSIX qw(strftime);
use Data::Dumper;

use PDF::API2;
use Text::CSV;
use Getopt::Long qw( :config auto_abbrev bundling );

use Carp 'croak', 'carp';

use string_with_components;

use constant now => [ localtime $^T ];
use constant this_year => strftime "%Y", localtime $^T;
use constant this_date => strftime "%Y%m%d", localtime $^T;
use constant sixteen_years_ago => strftime "%Y%m%d", localtime $^T - 504921600;

use constant CHECK_ARGS => 1;

use verbose;

################################################################################

use list_functions;

sub group_by_type(@) {
    return @_ if not @_ && $_[0]->can('gtags');
    my @rr_roles;
    my @rr_meetings;
    my @rr_people;
    my @rr_others;
    for my $r ( @_ ) {
        if ($r->gtags('meeting')) {
            push @rr_meetings, $r;
        }
        elsif ($r->gtags('role', 'admin')) {
            push @rr_roles, $r;
        }
        elsif ($r->gtags('members', 'attenders', 'child', 'inactive')) {
            push @rr_people, $r;
        }
        else {
            push @rr_others, $r;
        }
    }
    return @rr_meetings, @rr_roles, @rr_people, @rr_others;
}

sub sort_by_surname(@) {
    if ( my @x = grep { ! defined $_->{composite_name} } @_ ) { croak "Records don't have names:\n" . Dumper(\@x) }
    if ( my @x = grep { ! defined $_->{composite_name}->{sort_by_surname} } @_ ) { die "Records have names without sort-by-surname:\n" . Dumper(\@x) }
    return sort { $a->{composite_name}->{sort_by_surname}   cmp $b->{composite_name}->{sort_by_surname}
               || $a->{composite_name}->{sort_by_givenname} cmp $b->{composite_name}->{sort_by_givenname} } @_;
}
sub sort_by_givenname(@) {
    if ( my @x = grep { ! defined $_->{composite_name} } @_ ) { croak "Records don't have names:\n" . Dumper(\@x) }
    if ( my @x = grep { ! defined $_->{composite_name}->{sort_by_givenname} } @_ ) { die "Records have names without sort-by-givenname:\n" . Dumper(\@x) }
    return sort { $a->{composite_name}->{sort_by_givenname} cmp $b->{composite_name}->{sort_by_givenname}
               || $a->{composite_name}->{sort_by_surname}   cmp $b->{composite_name}->{sort_by_surname} } @_;
}
sub preferred_sort(@) {
    goto &sort_by_givenname;
}

use PDF::scale_factors;
use PDF::paginator;

use CSV::gmail;
use CSV::qndb;
use CSV::adhoc1;
use CSV::adhoc2;

################################################################################

use phone_functions;

use POSIX 'strftime';

sub show_date($) {
    for ( my $z = shift ) {
    s/T\d\d.*//;
    if (my @ymd = m/^(19\d\d|20[01]\d)\W*([012]\d)\W*(\d\d)$/) {
        warn "Date '$_' with year, ymd=[@ymd]" if $verbose > 3;
        if ($ymd[0] >= 1900 && $ymd[0] <= this_year && $ymd[1] <= 12 && $ymd[2] <= 31) {
            $_ = (strftime "%d %b %Y", 0,0,0,$ymd[2],$ymd[1]-1,$ymd[0]-1900,0,0)." ($_) (ymd)";
        }
    }
    elsif (my @dmy = m/^(\d\d)([012]\d)(19\d\d|20[01]\d)$/) {
        warn "Date '$_' with year, dmy=[@dmy]" if $verbose > 3;
        if ($dmy[2] >= 1900 && $dmy[2] <= this_year && $dmy[1] <= 12 && $dmy[0] <= 31) {
            $_ = (strftime "%d %b %Y", 0,0,0,$dmy[0],$dmy[1]-1,$dmy[2]-1900,0,0)." ($_) (dmy)";
        }
    }
    elsif (my @md = m/^\s*\-\-([012]\d)\-(\d\d)$/) {
        warn "Date '$_' without year, md=[@md]" if $verbose > 3;
        # day & month without year (GMail-style)
        if ($md[0] <= 12 && $md[1] <= 31) {
            $_ = (strftime "%d %b", 0,0,0,$md[1],$md[0]-1,-120,0,0)." ($_) (xmd)";
        }
    }
#   elsif ( m/./ ) {
#       warn "Date '$_' could not be matched" if $verbose > 2;
#   }
    warn "FIXED date $_" if $verbose > 3;
    return $_;
    }
}

sub show_qonu($) { $_[0] =~ /^GEN/ and return ''; return sprintf "http://quaker.org.nz/user/%s/edit/profile", shift }

my %show_fields = (
    birthdate                   => \&show_date,   # CSV::qndb
  # uid                         => \&show_qonu,   # CSV::qndb
  # uid_of_children_under_16    => \&show_qonu,   # CSV::qndb
  # uid_of_spouse               => \&show_qonu,   # CSV::qndb
  # uids_of_parents             => \&show_qonu,   # CSV::qndb
);

########################################

my $paper_sizes = {
        # A-series paper sizes, portrait
        (map {
            (my $x = $_) =~ s/^a//i;
            my $h = 2**(0.25-$x/2);
            my $w = $h / sqrt(2);
            ( ( $_ < 0 ? (2**-$_).'a0' : "a$_") => [ $h*1000*mm, $w*1000*mm ] );
        } -2 .. 10),
        # B-series paper sizes, portrait
        (map {
            (my $x = $_) =~ s/^b//i;
            my $h = 2**(0.5-$x/2);
            my $w = $h / sqrt(2);
            ( ( $_ < 0 ? (2**-$_).'b0' : "b$_") => [ $h*1000*mm, $w*1000*mm ] );
        } 0 .. 10),
        # C-series envelope sizes, landscape
        (map {
            (my $x = $_) =~ s/^c//i;
            my $w = 2**(0.375-$x/2);
            my $h = $w / sqrt(2);
            ( ( $_ < 0 ? (2**-$_).'c0' : "c$_") => [ $h*1000*mm, $w*1000*mm ] );
        } 0 .. 10),
        # DL envelope size, landscape
        dl => [ 110*mm, 220*mm ],
    };

########################################
# actual parsing of command-line

sub II(&) {
    my $f = pop;
    sub {
        for my $i ( split m{\s*,\s*}, $_[1] ) {
            my @k = split m{[=/]}, $i;
            $k[1] ||= '!post '.$k[0];
            $f->(@k);
        }
    }
}

sub as_points($) {
    my $v = $_[0];
    if ($v =~ s/[a-z]+$//) {
        state $units = {
            cm => 0.1*mm,
            in => in,
            m  => 1000*mm,
            mm => mm,
            pt => pt,
            px => px,
            Î¼m => 0.001*mm,
        };
        $v *= $units->{$&} || die "Unknown unit-of-measure $&\n";
    }
    $v;
}

################################################################################
#
# Process command-line options
#

use math_constants 'PHI';   # used in several default calculations...

########################################
# Decoding & parsing input files

my $csv_fs_char;
my $csv_quote_char;
my $csv_escape_char;
my $force_decoding;
my $presume_decoding;
my $use_encoding;

if (my $lang = $ENV{LANG}) {
    $presume_decoding =
    $use_encoding = 'UTF-8' if $lang =~ /\.UTF-8$/;
}

########################################
# How are records selected (these affect various modes in DWIM ways...)

my $need_region = 1;
my $skip_archived = 1;
my $skip_deceased = 1;
my $skip_meetings = 1;
my $skip_newsletters_only = undef;      # default to "yes" for do_book
my $skip_suppressed_listing = undef;    # default to "yes" for do_book
my $skip_suppressed_email = 0;
my $skip_suppressed_post = undef;       # default to "yes" for do_labels
my $skip_unlisted = 1;
my $skip_unsub = 1;
my @inclusion_labels;
my @inclusion_tags;
my $postal_control_tag = 'overseas';
my @restrict_classes;
my @restrict_regions;
my @selection_tags;

########################################
# Output selections

my $do_test = 0;
my $do_book = 0;
my $do_book_index_all;
my $do_book_index_by_mm;
my $do_book_index_by_wg;
my $do_book_listing_all;
my $do_book_listing_by_mm;
my $do_book_listing_by_wg;
my $do_diff = 0;
my $do_birthday_dump = 0;
my $do_diffable_dump = 0;
my $do_tag_report = 0;
my $do_labels = 0;
my $do_qndb_map = 0;
my $book_phones_first = 1;

my $output_name;
my $force_overwrite;

########################################
# Dump formatting options

my $names_only = 0;
my $output_bom = 0;
my $output_crlf;
my $show_relationships = 1;
my $show_uid;
my $suppress_adult_birthdays = 1;
my $suppress_send_by_post = 0;
my $suppress_send_by_email = 1;
my $suppress_status = 0;
my $suppress_yf_listing = 0;
my $show_hyperlinks = 1;
my $diff_by = 'uid';
my $diff_ignore_file;
my $diff_quietly = 0;

########################################
# Generic PDF output options (shared between labels and book generation)

my $page_size          ; # = 'a4';
my $page_height        ; # = 297.302*mm;
my $page_width         ; # = 210.224*mm;

my $page_left_margin   ; # = 18*mm;
my $page_right_margin  ; # = 18*mm;
my $page_bottom_margin ; # = 14*mm;
my $page_top_margin    ; # = 14*mm;

my $line_spacing = 1.25;    # ratio of font-size to line-pitch

my $extra_para_spacing = 0.25;  # used between records in book format

########################################
# Book formatting options

my $book_intercolumn_margin; #  = 10*mm;
my $book_interdetail_spacing = 1.75*mm;

my $book_sort_by_givenname;  # } will output BOTH lists if both these are selected
my $book_sort_by_surname;    # }

my $book_fontname  = 'Helvetica';
my $book_email_fontname  = 'Courier';
my $book_fontsize = 8.5*pt;     # depends on page size scaling
my $book_pagenumber_fontsize = $book_fontsize / PHI;
my $book_margin_fontsize = $book_fontsize * PHI;
my $use_page_numbers;

########################################
# Label formatting options

my $show_tiny_labels = 1;
my $use_cropbox = 0;
my $evenly_squash_to_fit = 0;

my $label_left_margin = 1*mm;
my $label_right_margin = 1*mm;
my $label_bottom_margin = 4*mm;
my $label_top_margin = 4*mm;

my $label_fontname = 'Helvetica';
my $label_fontsize = 12*pt;
my $label_postcode_fontsize = 14*pt;

my $label_banner_font = 'Helvetica';
my $label_banner_scale = PHI;
my $label_banner_colour = 'orange';

my $label_width;
my $label_height;
my $label_step_across;
my $label_step_down;
my $num_labels_across = 2;
my $num_labels_down = 4;
my $labels_ordered_in = 'columns';

########################################

    sub use_preset {
        my $pt = pop;

        state $x = warn Dumper($paper_sizes) if $verbose > 4 && $debug;

        state $label_product = {
            ( map { ( $_     => { page_size => $_,     page_height => $paper_sizes->{$_}->[0], page_width => $paper_sizes->{$_}->[1], num_labels_across => 2, num_labels_down => 3, } ) } keys %$paper_sizes ),
            ( map { ( $_.'R' => { page_size => $_.'R', page_height => $paper_sizes->{$_}->[1], page_width => $paper_sizes->{$_}->[0], num_labels_across => 3, num_labels_down => 2, } ) } keys %$paper_sizes ),

            'avery-l7160' => {
                    page_size            => 'a4',
                    page_height          => 297.302*mm,
                    page_width           => 210.224*mm,
                    num_across           => 3,
                    num_down             => 7,
                    page_top_margin      => 17.0*mm, label_top_margin     =>  1.5*mm,
                    page_bottom_margin   => 13.0*mm, label_bottom_margin  =>  1.5*mm,
                    page_left_margin     =>  5.0*mm, label_left_margin    =>  5.7*mm,
                    page_right_margin    =>  6.0*mm, label_right_margin   =>  7.7*mm,
                    ordered_in           => 'columns',
                },

            'book' => {
                    page_size          => 'a5',
                    page_height        => 210.224*mm,
                    page_width         => 148.651*mm,

                    page_left_margin   => 13*mm,
                    page_right_margin  => 13*mm,
                    page_bottom_margin => 10*mm,
                    page_top_margin    => 10*mm,
                    book_intercolumn_margin => 7*mm,
                },
            };

        state $y = warn Dumper($label_product) if $verbose > 4 && $debug;

        my $p = $label_product->{$pt} || die "Unknown label or paper product '$pt'\nAvailable presets are @{[sort keys %$label_product]}\n";
        (
            $page_size, $page_height, $page_width,
            $num_labels_across, $num_labels_down, $labels_ordered_in,
            $page_top_margin, $page_bottom_margin, $page_left_margin, $page_right_margin,
            $label_top_margin, $label_bottom_margin, $label_left_margin, $label_right_margin,
            $book_intercolumn_margin,
        ) = @$p{qw{
            page_size page_height page_width
            num_across num_down ordered_in
            page_top_margin page_bottom_margin page_left_margin page_right_margin
            label_top_margin label_bottom_margin label_left_margin label_right_margin
            book_intercolumn_margin
        }};
    }

my @ORIG_ARGV = @ARGV;

sub M($) { my $r = \$_[0]; sub { $$r = as_points $_[-1] } }
sub N($) { my $r = \$_[0]; sub { $$r = ! $_[1] } }
GetOptions

    'A=i'                         => sub { $page_size = $_[0].$_[1]; $page_width = $page_height = undef },  #A4 etc
    'B=i'                         => sub { $page_size = $_[0].$_[1]; $page_width = $page_height = undef },  #B4 etc
    'all-regions|any-region'      => sub { @restrict_regions = () },
    'book-index-all'              => \$do_book_index_all,
    'book-index-by-mm'            => \$do_book_index_by_mm,
    'book-index-by-wg'            => \$do_book_index_by_wg,
    'book-listing-all'            => \$do_book_listing_all,
    'book-listing-by-mm'          => \$do_book_listing_by_mm,
    'book-listing-by-wg'          => \$do_book_listing_by_wg,
    'book-names-first'            => N$book_phones_first,
    'book-phones-first'           => \$book_phones_first,
    'canonical-addresses!'        => \$CSV::Common::canon_address,
    'care-of!'                    => \$CSV::Common::use_care_of,
    'class|only-class=s'          => sub { push @restrict_classes, split /[, ]+/, pop },
    'explicitly-shared!'          => \$CSV::Common::only_explicitly_shared_email,
    'csv'                         => sub { $csv_fs_char = ',' },
    'debug|x'                     => sub { set_verbose 'debug='.$_[-1] },
    'decode-octet|decode-byte|db' => sub { $presume_decoding = 'OCTET' },
    'decode-utf16be|du16b'        => sub { $presume_decoding = 'UTF-16BE' },
    'decode-utf16le|du16l'        => sub { $presume_decoding = 'UTF-16LE' },
    'decode-utf8|du8'             => sub { $presume_decoding = 'UTF-8' },
    'decoding=s'                  =>      \$presume_decoding,
    'diff'                        => \$do_diff,
    'diff-quietly'                => \$diff_quietly,
    'diff-by-any'                 => sub { $diff_by = '' },
    'diff-by-name'                => sub { $diff_by = 'name' },
    'diff-by-uid'                 => sub { $diff_by = 'uid' },
    'diff-ignore-file=s'          => \$diff_ignore_file,
    'dump|diffable-dump'          => \$do_diffable_dump,
    'birthday-dump'               => \$do_birthday_dump,
    'encode-octet|encode-byte|eb' => sub { $use_encoding = 'OCTET' },
    'encode-utf16be|eu16b'        => sub { $use_encoding = 'UTF-16BE' },
    'encode-utf16le|eu16l'        => sub { $use_encoding = 'UTF-16LE' },
    'encode-utf8|eu8'             => sub { $use_encoding = 'UTF-8' },
    'encoding=s'                  =>      \$use_encoding,
    'escape-char=s'               => \$csv_escape_char,
    'force-decode-octet|force-decode-byte|fdb' => sub { $force_decoding = 'OCTET' },
    'force-decode-utf16be|fdu16b' => sub { $force_decoding = 'UTF-16BE' },
    'force-decode-utf16le|fdu16l' => sub { $force_decoding = 'UTF-16LE' },
    'force-decode-utf8|fdu8'      => sub { $force_decoding = 'UTF-8' },
    'force-decoding=s'            =>      \$force_decoding,
    'force-overwrite|f!'          => \$force_overwrite,
    'fs-char|sep-char=s'          => \$csv_fs_char,
    'hide-adult-birthdays!'       => \$suppress_adult_birthdays,
    'hide-hyperlinks!'            => N$show_hyperlinks,
    'hide-no-region!'             => \$need_region,
    'hide-relationships!'         => N$show_relationships,
    'hide-send!'                  => sub { $suppress_send_by_email = $suppress_send_by_post = $_[-1] },
    'hide-send-by-email!'         => \$suppress_send_by_email,
    'hide-send-by-post!'          => \$suppress_send_by_post,
    'hide-status!'                => \$suppress_status,
    'hide-uid!'                   => N$show_uid,
    'hide-yf-listing!'            => \$suppress_yf_listing,
    'include-archived!'           => N$skip_archived,
    'include-deceased!'           => N$skip_deceased,
    'include-meetings!'           => N$skip_meetings,
    'include-newsletters-only!'   => N$skip_newsletters_only,
    'include-no-region!'          => N$need_region,
    'include-suppressed-email!'   => N$skip_suppressed_email,
    'include-suppressed-listing!' => N$skip_suppressed_listing,
    'include-suppressed-post!'    => N$skip_suppressed_post,
    'include-unlisted!'           => N$skip_unlisted,
    'include-unsubscribed!'       => N$skip_unsub,
    'instruction-color|instruction-colour=s' => \$label_banner_colour,
    'label-height|lh=s'           => M$label_height,
    'label-step-across|lxw=s'     => M$label_step_across,
    'label-step-down|lxh=s'       => M$label_step_down,
    'label-width|lw=s'            => M$label_width,
    'labels'                      => \$do_labels,
    'labels-ordered-in-columns'   => sub { $labels_ordered_in = 'columns' },
    'labels-ordered-in-rows'      => sub { $labels_ordered_in = 'rows' },
    'labels-ordered-in=s'         => \$labels_ordered_in,
    'names-only!'                 => \$names_only,
    'need-region!'                => \$need_region,
    'num-labels-across|nla=i'     => \$num_labels_across,
    'num-labels-down|nld=i'       => \$num_labels_down,
    'octet|byte|b'                => sub { $presume_decoding = $use_encoding = 'OCTET' },
    'optional-include=s'          => II {                              push @inclusion_labels, $_[0]; push @inclusion_tags, $_[1]; },
    'output-bom|bom!'             => \$output_bom,
    'output-crlf|crlf!'           => \$output_crlf,
    'output|o=s'                  => \$output_name,
    'page-height|ph=s'            => sub { $page_size = undef; $page_height = as_points pop },
    'page-numbering!'             => \$use_page_numbers,
    'page-size=s'                 => sub { $page_size = pop; $page_width = $page_height = undef },  #A4, B3, etc
    'page-width|pw=s'             => sub { $page_size = undef; $page_width  = as_points pop },
    'preset=s'                    => \&use_preset,
    'qndb-map'                    => \$do_qndb_map,
    'quiet|q'                     => sub { set_verbose 0 },
    'quote-char=s'                => \$csv_quote_char,
    'raw-addresses!'              => N$CSV::Common::canon_address,
    'region|only-region=s'        => sub { push @restrict_regions, split /[, ]+/, pop },
    'select-and-include=s'        => II { push @selection_tags, $_[1]; push @inclusion_labels, $_[0]; push @inclusion_tags, $_[1]; },
    'select=s'                    => II { push @selection_tags, $_[1]; },
    'show-adult-birthdays!'       => N$suppress_adult_birthdays,
    'show-hyperlinks!'            => \$show_hyperlinks,
    'show-relationships!'         => \$show_relationships,
    'show-send!'                  => sub { $suppress_send_by_email = $suppress_send_by_post = ! $_[-1] },
    'show-send-by-email!'         => N$suppress_send_by_email,
    'show-send-by-post!'          => N$suppress_send_by_post,
    'show-status!'                => N$suppress_status,
    'show-uid!'                   => \$show_uid,
    'show-yf-listing!'            => N$suppress_yf_listing,
    'skip-archived!'              => \$skip_archived,
    'skip-deceased!'              => \$skip_deceased,
    'skip-meetings!'              => \$skip_meetings,
    'skip-newsletters-only!'      => \$skip_newsletters_only,
    'skip-suppressed-email!'      => \$skip_suppressed_email,
    'skip-suppressed-listing!'    => \$skip_suppressed_listing,
    'skip-suppressed-post!'       => \$skip_suppressed_post,
    'skip-unlisted!'              => \$skip_unlisted,
    'skip-unsubscribed!'          => \$skip_unsub,
    'sort-book-by-givenname'      => \$book_sort_by_givenname,
    'sort-book-by-surname'        => \$book_sort_by_surname,
    'tag-report'                  => \$do_tag_report,
    'test'                        => \$do_test,
    'tsv'                         => sub { $csv_fs_char = "\t"; $csv_escape_char = $csv_quote_char = ""; },
    'utf16be|u16b'                => sub { $presume_decoding = $use_encoding = 'UTF-16BE' },
    'utf16le|u16l'                => sub { $presume_decoding = $use_encoding = 'UTF-16LE' },
    'utf8|u8|u'                   => sub { $presume_decoding = $use_encoding = 'UTF-8' },
    'v+'                          => \&set_verbose,
    'verbose=s'                   => \&set_verbose,
    'why-not|why-skipped'         => sub { set_verbose 'why='.$_[-1] },

    'help|h'                      => sub { print <<EndOfHelp ; exit 0 },
$0 --book-{index|listing}-{all|by-{mm|wg}} [book-options|pdf-output-options|generic-options]...
$0 --labels [label-options|pdf-output-options|generic-options]...
$0 --diff [diff-options|dump-options|text-output-options|generic-options]...
$0 --dump [dump-options|text-output-options|generic-options]...
$0 --qndb-map [qndb-map-options|text-output-options|generic-options]...

For additional options see:
    $0 --help-book
    $0 --help-diff
    $0 --help-dump
    $0 --help-labels
    $0 --help-qndb

    $0 --help-generic

    $0 --help-input
    $0 --help-selection
    $0 --help-tuning

    $0 --help-output
    $0 --help-pdf
EndOfHelp

    'help-diff'                   => sub { print <<EndOfHelp; exit 0 },
diff-options:
    --names-only
    --names-only
    --diff-quietly
    --diff-by-any
    --diff-by-name
    --diff-by-uid
    (plus dump-options)

See:
    $0 --help-dump
    $0 --help-output
    $0 --help-generic
EndOfHelp

    'help-dump'                   => sub { print <<EndOfHelp; exit 0 },
dump-options:
    --[no-]names-only
    --[no-]{show|hide}-adult-birthdays
    --[no-]{show|hide}-hyperlinks
    --[no-]{show|hide}-relationships
    --[no-]{show|hide}-send
    --[no-]{show|hide}-send-by-email
    --[no-]{show|hide}-send-by-post
    --[no-]{show|hide}-uid
    --[no-]{show|hide}-status
    --[no-]{show|hide}-yf-listing
    (plus text-output-options)

See also:
    $0 --help-output
    $0 --help-generic
EndOfHelp

    'help-qndb'                   => sub { print <<EndOfHelp; exit 0 },
qndb-map-options (with --qndb-map):
    (none yet)
    (plus text-output-options)

See:
    $0 --help-output
    $0 --help-generic
EndOfHelp

    'help-book'                   => sub { print <<EndOfHelp; exit 0 },
book-options:
    --book-index-all
    --book-index-by-mm
    --book-index-by-wg
    --book-listing-all
    --book-listing-by-mm
    --book-listing-by-wg
    --book-names-first          tabulate main list as: name, phone, address
    --book-phones-first         tabulate main list as: phone, name, address
    --sort-book-by-{surname|givenname}  NB: will output BOTH lists if both these are selected
    (plus pdf-output-options)

See:
    $0 --help-pdf
    $0 --help-generic
EndOfHelp

    'help-labels'                 => sub { print <<EndOfHelp; exit 0 },
label-options (with --labels):
    --preset={avery-l7160|...}
    --instruction-colour=COLOUR     colour of metadata labels
    --label-height=LENGTH       --lh=LENGTH
    --label-step-across=LENGTH  --lxw=LENGTH
    --label-step-down=LENGTH    --lxh=LENGTH
    --label-width=LENGTH        --lw=LENGTH
    --labels-ordered-in={columns|rows}
    --labels-ordered-in-{columns|rows}
    --num-labels-across=NUM     --nla=NUM
    --num-labels-down=NUM       --nld=NUM
    (plus pdf-output-options)

See:
    $0 --help-pdf
    $0 --help-generic
EndOfHelp

    'help-pdf'                    => sub { print <<EndOfHelp; exit 0 },
pdf-output-options
    --page-size={A0,A1,...,B0,B1,...}
    -A{0...9}  -B{0...9}                ISO paper sizes
    --page-height=LENGTH  --ph=LENGTH
    --page-width=LENGTH  --pw=LENGTH
EndOfHelp

    'help-output'                 => sub { print <<EndOfHelp; exit 0 },
text-output-options:
    --[no-]output-bom       --[no-]bom
    --[no-]output-crlf      --[no-]crlf
    --encoding={OCTET|UTF-{8|16|16LE|16BE|32|32LE|32BE}}
        --encode-octet --encode-byte    --eb        (--encoding=OCTET)
        --encode-utf16be                --eu16b     (--encoding=UTF-16BE)
        --encode-utf16le                --eu16l     (--encoding=UTF-16LE)
        --encode-utf8                   --eu8       (--encoding=UTF-8)
    --output=FILENAME -oFILENAME

  * conjoint input & output text options
        --octet  --byte  -b                         (--decoding=OCTET    --encoding=OCTET)
        --utf8  --u8                                (--decoding=UTF-8    --encoding=UTF-8)
        --utf16be  --u16b                           (--decoding=UTF-16BE --encoding=UTF-16BE)
        --utf16le  --u16l                           (--decoding=UTF-16LE --encoding=UTF-16LE)
EndOfHelp

    'help-generic'                => sub { print <<EndOfHelp; exit 0 },
generic-options:
    -v[v...] | --verbose | -q | --quiet
    -x | --debug                    enable debugging output
    --[no-]force-overwrite -f       clobber preexisting output files
    (plus input-options)
    (plus record-selection-options)
    (plus record-tuning-options)

See also:
    $0 --help-input
    $0 --help-selection
    $0 --help-tuning
EndOfHelp

    'help-input'                  => sub { print <<EndOfHelp; exit 0 },
 input-options:
    --decoding                  assume input encoding if it cannot be deduced
    --force-decoding            assume input encoding overriding any deduction
    --decoding={OCTET|UTF-{8|16|16LE|16BE|32|32LE|32BE}}
        --decode-octet --decode-byte    --db (--decode-octet)
        --decode-utf16be                --du16b (--decode-utf16be)
        --decode-utf16le                --du16l (--decode-utf16le)
        --decode-utf8                   --du8 (--decode-utf-8)
    --csv                       assume input is comma-separated
    --tsv                       assume input is tab-separated
    --fs-char=CHAR --sep-char=CHAR  field separating character
    --quote-char=CHAR               quote character
    --escape-char=CHAR              escape character
EndOfHelp

    'help-selection'              => sub { print <<EndOfHelp; exit 0 },
 record-selection-options:
    --[only-]region=REGION[,REGION...]          exclude records not in any of the REGIONs
    --all-regions           --any-region        include records with any region
    --no-need-region --no-hide-no-region     --include-no-region include records without a region
       --need-region    --hide-no-region  --no-include-no-region exclude records without a region
    --[no-]include-archived --[no-]skip-archived
    --include-deceased      --skip-deceased
    --include-meetings      --skip-meetings
    --include-unsubscribed  --skip-unsubscribed
    --only-region=REGION
    --select-and-include=TAG[,TAG...]
    --select=TAG[,TAG...]
    --optional-include=TAG[,TAG...]
    --why-not  --why-skipped        [explain exclusion of each record]
EndOfHelp

    'help-tuning'                 => sub { print <<EndOfHelp; exit 0 },
 record-tuning-options:
       --canonical-addresses --no-raw-addresses     convert address elements to canonical abbreviations (e.g. Street -> St)
    --no-canonical-addresses    --raw-addresses     don't convert address elements to canonical abbreviations (e.g. Street -> St)
       --care-of                                    include 'c/-' where it would be inferred from the "type" field
    --no-care-of                                    omit 'c/-' where it would be inferred from the "type" field
EndOfHelp

    or exit 64;

$verbose and *STDOUT{IO}->autoflush(1);
$verbose and *STDERR{IO}->autoflush(1);

$verbose and warn sprintf "RUN: %s\n", join ' ', map { ! m{[^0-9A-Za-z!#%+,-./:=@^_~]|^\#} ? $_ : ! m/['\\]/ ? "'$_'" : ! m/["\\\$]/ ? '"'.$_.'"' : s{[^0-9A-Za-z!#%+,-./:=@^_~]}{\\$&}gr } $0, @ORIG_ARGV;

########################################
#
# Compute some derivative fallback values for parameters that can also be set
# on commandline
#

use quaker_info '%mm_names';

$_ = uc $_ for @restrict_regions;
@restrict_regions = grep { $_ ne 'NONE' or $need_region = 0; } @restrict_regions;

$mm_names{$_} or die "Invalid region '$_'\n" for @restrict_regions;

warn "RESTRICTION: limit to regions: @restrict_regions\n" if $verbose > 2;

$do_book ||= $do_book_index_by_wg || $do_book_index_by_mm || $do_book_index_all || $do_book_listing_by_wg || $do_book_listing_by_mm || $do_book_listing_all || 0;

# Default exclusions for different generation types
$skip_suppressed_listing //= $do_book;
$skip_newsletters_only   //= $do_book;
$skip_suppressed_post    //= $do_labels;

my @wr_binmode;
my @wr_bom;
if ( $use_encoding && $use_encoding ne 'OCTET' ) {
    @wr_binmode = ":encoding($use_encoding)";
    @wr_bom = "\x{feff}" if $output_bom;
    binmode STDERR, "@wr_binmode";
}
$output_crlf and push @wr_binmode, ":crlf";
unshift @wr_binmode, ":raw" if @wr_binmode;
warn "WRITE BINMODE=@wr_binmode\n" if $verbose > 1 && @wr_binmode;

$book_sort_by_surname //= ! $book_sort_by_givenname;

# punctuation in tags is ignored by gtags()
s/^\W*// for @selection_tags,
             @inclusion_tags;

{

################################################################################
#
# Parse input file(s)
#
# Mostly we automatically adapt to the input format, so we can read
#  - CSV dumps from Drupal
#  - CSV dumps from Gmail (both UTF8 and UTF16LE)
#  - CSV input for the interrim label generator
#

sub open_file_for_reading($) {
    my $in_name = "(stdin)";
    my $in = shift;

    my $fsep = $csv_fs_char;
    my $echar = $csv_escape_char;
    my $qchar = $csv_quote_char;

    if (!ref $in) {
        # param is *not* a filehandle
        if (!$in || $in eq '-') {
            # param is '' or '-', use stdin
            $in = *STDIN{IO};
        }
        else {
            # param is filename, so open it
            $in_name = $in;
            $in = undef;
        }
    }

    my $s = '';
    my $seekable;
    my $seek_to = 0;
    my $look_ahead = sub {
        my ($n) = @_;
        # Open the file if it isn't yet
        open $in, '<:raw', $in_name or die "Can't open $in_name; $!\n" if !$in;
        # Note whether it's seekable; do this before attempting to read any data
        # so that we don't disrupt buffering later.
        $seekable //= seek $in, 0, SEEK_CUR;
        # Read & return the requested number of bytes
        $n -= length $s;
        if ( $n > 0 ) {
            local $/ = \$n;
            $s .= (<$in> // '');
        }
        return $s;
    };
    my $look_match = sub {
        my ($m) = @_;
        my $l = length $m;
        while ( $l > length $s ) {
            $s eq substr($m,0,length $s) or return;
            $look_ahead->(1+length $s);
        }
        substr($s,0,$l) eq $m or return;
        $seek_to = $l;
        return 1;
    };

    warn "STARTING file '$in_name'\n" if $verbose;

    my @rd_binmode;
    my $rd_crlf = 1;
    my $decoding;

    #
    # Override all autodetection including Byte Order Marks, when given
    # --force-decode=XXXX; this isn't normally needed, but might be
    # necessary if the input can't be rewound such as for a pipe, or if
    # by pure bad luck the input appears to start with a BOM when in fact
    # that's data.
    #
    # In this case, we don't need to inspect the input stream at all...
    #
    if    ( $force_decoding                   ) { $decoding = $force_decoding }

    #
    # Deduce the encoding by reading the first chunk and looking for a Unicode
    # Byte Order Mark (BOM, \ufeff).
    #
    elsif ( $look_match->("\xef\xbf\xbe"    ) ) { $decoding = 'UTF-8' }
    elsif ( $look_match->("\xff\xfe\x00\x00") ) { $decoding = 'UTF-32LE' }
    elsif ( $look_match->("\x00\x00\xfe\xff") ) { $decoding = 'UTF-32BE' }
    elsif ( $look_match->("\xfe\xff"        ) ) { $decoding = 'UTF-16BE' }
    elsif ( $look_match->("\xff\xfe"        ) ) { $decoding = 'UTF-16LE' }

    #
    # In the absence of a BOM, use the decoding given as --decoding=XXXX.
    #
    elsif ( $presume_decoding                 ) { $decoding = $presume_decoding }

    #
    # Guess based on the input stream: assume UTF-8 if nothing in the stream
    # conflicts with it; otherwise infer the word size and endianness from the
    # pattern of NULs.
    #
    else {
        #
        # If seekable use a big chunk to improve detection reliability; if
        # not seekable use a small chunk to maximize the chance that
        # pushback will work.
        #
        # (This assumes that the first row starts with an ASCII character,
        # which is usually valid if the first row is actually a header with
        # field labels.)
        #
        my $s = $look_ahead->( $seekable ? 8192 : 512 );
        if ( $s !~ m{ [^\x80-\xff][\x80-\xbf]
                    | [\xc0-\xff][^\x80-\xbf]
                    | [\xe0-\xff].[^\x80-\xbf]
                    | [\xf0-\xff]..[^\x80-\xbf]
                    | [\xf8-\xff]...[^\x80-\xbf]
                    | [\xfc-\xff]....[^\x80-\xbf]
                    | [\x00\xc0\xc1\xfe\xff]      }x ) { $decoding = 'UTF-8';    }
        elsif ( $s =~ m{^ \x00\x00\x00[\x20-\x7f] }x ) { $decoding = 'UTF-32BE'; }
        elsif ( $s =~ m{^ \x00[\x20-\x7f]         }x ) { $decoding = 'UTF-16BE'; }
        elsif ( $s =~ m{^ [\x20-\x7f]\x00\x00\x00 }x ) { $decoding = 'UTF-32LE'; }
        elsif ( $s =~ m{^ [\x20-\x7f]\x00         }x ) { $decoding = 'UTF-16LE'; }
        else                                           { $decoding = 'OCTET';    }
        warn sprintf "Guessing %s for %s (no BOM)\n", $decoding, $in_name;
    }

    #
    # Take this opportunity to look for tab characters to infer their use
    # as the field separator, and for carriage-return characters to infer
    # cr-lf line endings.
    #
    $fsep = $&, $echar = $qchar = "" if !$fsep && $look_ahead->(512) =~ m/\t/;
    $rd_crlf //= $look_ahead->(512) =~ m{\r\n} ? 1 : 0;

    #
    # Seek (or push-back) to start of input, but after any BOM.
    #
    # Note that seeking may cause a buffer flush even if it's unsuccessful,
    # which might then cause the pushback to fail, so avoid trying to seeking
    # if we already know it will fail.
    #
    if ($seek_to != length $s) {
        if ( not $seekable && seek $in, $seek_to, SEEK_SET ) {
            for ( unpack 'C*', reverse substr $s, $seek_to ) {
                $in->ungetc($_) or die "Can neither seek nor pushback within $in_name; $!\n"
            }
        }
    }

    push @rd_binmode, ":encoding($decoding)" if $decoding && $decoding ne 'OCTET';
    push @rd_binmode, ":crlf" if $rd_crlf;
    unshift @rd_binmode, ':raw' if @rd_binmode;
    warn "READ BINMODE=@rd_binmode\n" if $verbose > 1 && @rd_binmode;
    if (!$in) {
        open $in, "<@rd_binmode", $in_name or die "Can't open $in_name [@rd_binmode]; $!\n";
    }
    else {
        binmode $in, "@rd_binmode" or die "Can't set binmode(@rd_binmode) on $in_name; $!\n" if @rd_binmode;
    }

    return $in, $in_name, $fsep, $echar, $qchar;
}

sub parse_file($) {
    my ( $in, $in_name, $fsep, $echar, $qchar ) = open_file_for_reading shift;

    my $filetype;
    $fsep ||= ',';
    $echar //= '"';
    $qchar //= '"';

    my $csv = Text::CSV::->new({ binary => 1, sep_char => $fsep, escape_char => $echar, quote_char => $qchar }) or die "Can't construct CSV reader; $!";

    my @headers = do {
            my $r0 = $csv->getline($in) or die "Can't get header line from $in_name\n";
            print "Read headers: " . Dumper($r0) if $verbose > 4 && $debug;
            $r0->[0] =~ s/^\x{fffe}// and die "Can't process $in_name -- starts with reverse BoM!\n";
            $r0->[0] =~ s/^\x{feff}// and warn "Ignoring leading BoM in $in_name\n";            # ignore Byte-Order-Mark
            $r0->[0] =~ s/^!// and warn "Ignoring leading ! in $in_name\n";     # a leading "!" may be used to force headers to sort to beginning of file
            if ($r0->[0] =~ /^%/) {
                $filetype = PDF::adhoc2::;
                # There is no "header row" as such, so the first row is actually structured data...
                $filetype->new(undef, $r0);
            }
            elsif ($r0->[0] eq 'uid') {
                $filetype = CSV::qndb::;
            }
            elsif ($r0->[0] eq 'Name') {
                $filetype = CSV::gmail::;
            }
            elsif ($r0->[0] eq 'inserts' ) {
                $filetype = CSV::adhoc1::;
            }
            else {
                die "Unknown file type, headers=[@$r0]\n";
            }
            map { s/\W+/_/g; lc $_ } @$r0;
        };
    warn "Parsed headers: " . Dumper(\@headers) if $verbose > 4 && $debug;

    my $num_lines = $. - 1;
    my @records;
    my %record_by_uid;
    $! = 0;
    RECORD: while ( my $ra = $csv->getline($in) ) {
        $num_lines = $. - 1;
        print "Read line#$num_lines: " . Dumper($ra) if $verbose > 5 && $debug;
        my @r = $filetype->new(\@headers, $ra);
        push @records, @r;
        $record_by_uid{$_->uid} = $_ for @r;
        $! = 0;
    }

    warn sprintf "READ: parsed %u records from %u lines in %s\n", scalar(@records), $num_lines, $in_name if $verbose;
    warn sprintf "READ: file position now at %#x in %s\n", tell($in), $in_name if $verbose > 1;
    close $in or die "Error while reading $in_name; $!\n";

    RECORD: for my $r ( @records ) {
        if ( $r->{ZREF_parents} || $r->{ZREF_children} ) {
            $r->{XREF_parents}  = delete $r->{ZREF_parents};
            $r->{XREF_children} = delete $r->{ZREF_children};
        } else {
            my $uid = $r->uid;
            for my $uid_of_kid ($r->uid_of_children_under_16) {
                my $k = $record_by_uid{$uid_of_kid} or next RECORD;
                push @{$k->{LIST_uids_of_parents}}, $uid;
                push @{$k->{XREF_parents}}, $r;
                push @{$r->{XREF_children}}, $k;
            }
            if (my ($uid_of_spouse) = $r->uid_of_spouse) {
                my $s = $record_by_uid{$uid_of_spouse} or do { warn sprintf "Record with uid#%s (name:%s) claims spouse with uid#%s, who does not exist\n", $uid, $r->name, $uid_of_spouse; next; };
                $r->{XREF_spouse} = $s;
                $s->isa(CSV::Common::) or die "Not a CSV::Common record\n".Dumper($s);
                my ($s2uid) = $s->uid_of_spouse or do { warn sprintf "Record with uid#%s (name:%s) claims spouse with uid #%s, who has no spouse\n", $uid, $r->name, $uid_of_spouse; next; };
                $s2uid eq $uid or do { warn sprintf "Record with uid#%s (name:%s) claims spouse with uid #%s, who has a different spouse with uid#%s\n", $uid, $r->name, $uid_of_spouse, $s2uid; next; };
                $s->{XREF_spouse} = $r;
               #$r->isa(CSV::Common::) or die "Not a CSV::Common record ".Dumper($r);
            }
        }
    }

    warn sprintf "READ: cross-referenced %u records from %s\n", scalar @records, $in_name if $verbose;

    return \@records;
}

    sub _open_output($;$) {
        my $output = shift;
        my $raw = shift;
        my @binmode = $raw ? () : @wr_binmode;
        my @bom     = $raw ? () : @wr_bom;
        flush STDOUT;
        flush STDERR;
        if ($output && ! ref $output && $output ne '-') {
            $force_overwrite || ! -e $output or die "Output file '$output' already exists; use --force-overwrite\n";
            open my $outx, ">@binmode", $output or die "Can't create $output; $!\n";
            print $outx @bom if @bom;
            return $outx, $output;
        }
        else {
            state %first;
            ref $output or $output = *STDOUT{IO};
            if ( !$first{$output}++ ) {
                binmode $output, "@binmode" or warn "Can't set binmode on $output (@binmode); $!\n" if @binmode;
                print $output @bom if @bom;
            }
            return $output, '(stdout)';
        }
    }

    sub _choose_ofields() {
        my @ofields;
        # 'name' is not required; always printed, separately from fields list
        push @ofields, qw( monthly_meeting_area formal_membership inactive ) unless $names_only || $suppress_status;
        push @ofields, qw( show_me_in_young_friends_listing ) unless $names_only || $suppress_yf_listing;
        push @ofields, qw( listed_email phone_number mobile_number fax listed_address postal_address ) unless $names_only;
        push @ofields, qw( receive_local_newsletter_by_post nz_friends_by_post) unless $names_only || $suppress_send_by_post;
        push @ofields, qw( receive_local_newsletter_by_email nz_friends_by_email ) unless $names_only || $suppress_send_by_email;
                       # Possible additional fields:
                       #   synthesized website_url rd_no po_box_number country postcode
                       #   town suburb address property_name users_name
                       #   uid_of_children_under_16 uid_of_spouse uid first_name
                       #   family_name
        push @ofields, qw( uid uid_of_spouse uid_of_children_under_16 uids_of_parents ) if $show_uid;
        return grep { ! /^#/ } @ofields;
    }

    sub _dump_one($$$) {
        my ($out, $r, $ofields) = @_;
        my $ov = $verbose;
        {
            # Fixed fields: name, sort-keys, birthday
            my $v = $r->name || do { warn "UNNAMED RECORD\n" . Dumper($r); '(unknown)' };
            if ($show_hyperlinks and my $ru = $r->uid) {
                if ($ru !~ /^GEN/) {
                    my $rl = show_qonu($ru);
                    $v .= "  $rl";
                }
            }
            if ($r->can("gtags") && $r->gtags("suppress listing")) {
                $v .= "  [SUPPRESSED LISTING]";
            }
            printf $out "%s: %s\n", "name", $v;
            printf $out "%s: %s\n", "sort-by-surname", $r->{composite_name}->{sort_by_surname};
            printf $out "%s: %s\n", "sort-by-givenname", $r->{composite_name}->{sort_by_givenname};
            if ( my $bd = $r->birthdate ) {
                my ($y,$m,$d,$ymd) = ($1,$2,$3,"$1$2$3") if $bd =~ m#^(\d{4})\W*(\d{2})\W*(\d{2})(?:T[:0-9]{8}|\W*)$#;
                if ( ! $suppress_adult_birthdays || $ymd gt sixteen_years_ago ) {
                    $bd = show_date($bd);
                    printf $out "%s: %s\n", 'Birthday', $bd;
                }
            }
        }
        FIELD: for my $f (@$ofields) {
            my @v;
            if (my $ff = $r->can($f)) {
                @v = $ff->($r);
                #push @v, "can($f)";
            }
            elsif (exists $r->{"LIST_$f"}) {
                @v = @{ $r->{"LIST_$f"} };
                #push @v, "_list($f)";
            }
            elsif (exists $r->{$f}) {
                @v = $r->{$f} // ();
                #push @v, "{$f}";
            }
            else {
                if ($verbose > 1) {
                    warn "Missing field '$f' in $r\n".Dumper($r);
                }
                elsif ($verbose) {
                    warn "Missing field '$f' in $r\n";
                }
            }
            @v = grep { defined $_ && "$_" ne '' } @v;
            defined $v[0] or next FIELD;
            if (my $fn = $show_fields{$f}) {
                $_ = $fn->($_) for @v
            }
            for my $v (@v) {
                if ($v =~ /\n/) {
                    printf $out "%s:\n%s\n", $f, $v;
                }
                else {
                    printf $out "%s: %s\n", $f, $v;
                }
            }
        }
        if ($show_relationships) {
            if ( my $s = $r->{XREF_spouse} ) {
                #$s->isa(CSV::Common::) or die "Not a CSV::Common record: ".Dumper($s);
                my $v = $s->name || '(unknown)';
                if ($show_hyperlinks and my $su = $s->uid) {
                    my $sl = show_qonu($su);
                    $v .= "  $sl";
                }
                printf $out "%s: %s\n", "spouse", $v;
            }
            if (my $pp = $r->{XREF_parents}) {
                for my $p ( preferred_sort @$pp ) {
                    #$p->isa(CSV::Common::) or die "Not a CSV::Common record: ".Dumper($p);
                    my $v = $p->name || '(unknown)';
                    if ($show_hyperlinks and my $pu = $p->uid) {
                        my $pl = show_qonu($pu);
                        $v .= "  $pl";
                    }
                    printf $out "%s: %s\n", "parent", $v;
                }
            }
            if (my $cc = $r->{XREF_children}) {
                for my $c ( preferred_sort @$cc ) {
                    #$c->isa(CSV::Common::) or die "Not a CSV::Common record: ".Dumper($c);
                    my $v = $c->name || '(unknown)';
                    if ($show_hyperlinks and my $cu = $c->uid) {
                        my $cl = show_qonu($cu);
                        $v .= "  $cl";
                    }
                    printf $out "%s: %s\n", "child", $v;
                }
            }
        }
      # die Dumper($r) if $r->name =~ /Beryl\s*Riley/;
        print $out Dumper($r) if $verbose > 4 && $debug;
        $verbose = $ov;
    }

################################################################################
#
# Generate a report of differences between two files
#

    # Take two lists, and expand them with undefs so that equal elements line up.
    # Work by picking the longest common subsequence, then recursively operating
    # on the parts either side of that.
    # If there are no equal elements, just pad the two lists to the same length.
    sub _diff_align(&\@\@) {
        my ($cmp, $l1, $l2) = @_;
        #my $verbose = $#$l1 + $#$l2 > 6;
        my @stack = [ 0, $#$l1, 0, $#$l2 ];
        #flush STDOUT if $verbose;
        #warn "START\n" if $verbose;
        while (my $q = pop @stack) {
            #warn "STEP: ".Dumper(["RANGE", $q, "LIST1", $l1, "LIST2", $l2, "STACK", \@stack]) if $verbose;
            my ( $s1, $e1, $s2, $e2) = @$q;
            my $d = ($e1-$s1) - ($e2-$s2);
            if ($s1 > $e1) {
                #warn sprintf "INSERT %u into LIST1 at %u\n", -$d, $e1+1 if $verbose;
                splice @$l1, $e1+1, 0, (undef) x -$d;
                next;
            }
            if ($s2 > $e2) {
                #warn sprintf "INSERT %u into LIST2 at %u\n", $d, $e2+1 if $verbose;
                splice @$l2, $e2+1, 0, (undef) x $d;
                next;
            }
            # find maximal common stretch, with minimal offset from the centres
            my $ml = int( (($e1-$s1) + ($e2-$s2)) / 2 );
            my $mo = int( (($e1-$s1) - ($e2-$s2)) / 2 );
            my $pos;
            my $off;
            my $len = 0;
            for my $o ( $mo, map { $mo+$_, $mo-$_ } 1 .. $ml+1 ) {
                my $i = max $s1, $s2-$o;
                my $e = min $e1, $e2-$o;
                #warn sprintf "CHECK LIST1[%d..%d] against LIST2[%d..%d]\n", $i, $e, $i+$o, $e+$o if $verbose;
                for (; $i <= $e ;++$i) {
                    if ( $cmp->($l1->[$i], $l2->[$i+$o]) ) {
                        my ($z) = grep { !$cmp->($l1->[$_], $l2->[$_+$o]) } $i .. $e;  # index of next non-matching element
                        $z //= $e+1;            # if all the rest match, then there is no "next non-matching element"
                        if ($len < $z-$i) {
                            # found a new longest subset
                            $len = $z-$i;
                            $pos = $i;
                            $off = $o;
                        }
                        $i = $z;
                    }
                }
            }
            if (defined $pos) {
                # found a common subset; perform alignment on the parts either side
                #warn sprintf "COMMON %u at LIST1[%u..%u] and at LIST2[%u..%u]\n", $len, $pos, $pos+$len-1, $pos+$off, $pos+$off+$len-1 if $verbose;
                push @stack, [ $s1,       $pos-1, $s2,            $pos+$off-1 ],
                             [ $pos+$len, $e1,    $pos+$off+$len, $e2         ];
            }
            else {
                #warn sprintf "ALLDIFF\n" if $verbose;
                if ($d<0) {
                    splice @$l1, $e1+1, 0, (undef) x -$d;
                }
                else {
                    splice @$l2, $e2+1, 0, (undef) x $d;
                }
            }
        }
        #warn "DONE\n" if $verbose;
    }

use quaker_info '$mm_keys_re';

    sub _skip_restricted_record($) {
        my $r = shift;

        if (@restrict_regions) {
            my $skip = 0;
            my $where;
            my @mt;
            if ( $r->can('gtags') ) {
                $where = 'gmail';
                $r->isa(CSV::qndb::) and die "gtags shouldn't work on QNDB record; method=".$r->can('gtags');
                if ( @mt = $r->gtags( qr/^(?:member|listing)[- ]+($mm_keys_re|YF)\b/ ) ) {
                    grep { my $reg = $_; grep { $_ eq $reg } @mt } @restrict_regions
                    or $skip = 1;
                }
                elsif ($need_region) {
                    $skip = 2;
                }
            }
            else {
                $where = 'profile';
                if ( @mt = map {
                                    my $a = $r->{$_} || '';
                                    $a =~ m{^($mm_keys_re|YF)\b} ? $1 : ()
                                } qw{   formal_membership
                                        monthly_meeting_area
                                       } ) {
                                    # Also, maybe:
                                    # - receive_local_newsletter_by_post
                                    # - receive_local_newsletter_by_email
                    grep {
                            my $reg = $_;
                            grep { $_ eq $reg } @mt;
                        } @restrict_regions
                    or $skip = 3;
                }
                elsif ($need_region) {
                    $skip = 4;
                }
            }
            if ($skip) {
                warn sprintf "Skipping REGION %s doesn't have %s%s\n",
                            $r->debuginfo,
                            @mt ? 'any of the wanted regions ('.join(', ', @mt).')' : 'any regions',
                            $where,
                    if $why_not;
                return 1;
            }
        }
        if ( $r->can('gtags') ) {
            if ($need_region) {
                if ( ! $r->gtags( qr/^(?:member|listing)[- ]+($mm_keys_re|YF)\b/ ) ) {
                    warn sprintf "Skipping NOREGION %s\n", $r->debuginfo if $why_not;
                    return 1;
                }
            }
            if ($skip_archived) {
                if ( my @s = $r->gtags( qr/^archive - (.*)/ ) ) {
                    warn sprintf "Skipping ARCHIVED %s [%s]\n", $r->debuginfo, "@s" if $why_not;
                    return 1;
                }
            }
            state $skips = do {
                my @skips;
                push @skips, 'archive - deceased'     if $skip_deceased && !$skip_archived;
                push @skips, 'archive - unsubscribed' if $skip_unsub    && !$skip_archived;
                push @skips, 'meetings'               if $skip_meetings;
                push @skips, 'suppress listing'       if $skip_suppressed_listing;
                push @skips, 'newsletters-only'       if $skip_newsletters_only;
                push @skips, 'suppress email'         if $skip_suppressed_email;
                push @skips, 'suppress post'          if $skip_suppressed_post;
                \@skips;
            };
            if ( @$skips && $r->gtags(@$skips) ) {
                warn sprintf "Skipping TAGGED %s tagged with [%s]\n", $r->debuginfo, join "; ", @$skips if $why_not;
                return 1;
            }
            if ( @restrict_classes ) {
                if (! $r->gtags( @restrict_classes )) {
                    warn sprintf "Skipping EXCLASS %s not in [%s]\n", $r->debuginfo, join "; ", @restrict_classes;
                    return 1;
                }
            }
            if ($skip_unlisted) {
                if (! $r->gtags( 'meeting', 'role', 'admin', 'members', 'attenders', 'child', 'inactive' )) {
                    if ( $why_not ) {
                        if ($r->gtags( 'newsletter-only' )) {
                            warn sprintf "Skipping NEWS-ONLY %s\n", $r->debuginfo;
                        } else {
                            warn sprintf "Skipping NON-PERSON %s\n", $r->debuginfo;
                        }
                    }
                    return 1;
                }
            }
        }
      # elsif ( UNIVERSAL::isa($r, PDF::adhoc2::) ) {
      #     return 0;
      # }
        else {
            if ($skip_meetings && (! $r->{monthly_meeting_area} &&
            ! $r->{formal_membership} &&
            ! ( $r->{show_me_in_young_friends_listing}
             && $r->{show_me_in_young_friends_listing} eq 'Yes' ))) {
                warn sprintf "Skipping UNLISTED %s [no MM membership, WG listing, or YF listing]\n", $r->debuginfo if $why_not;
                return 1;
                #$r->name =~ /Bakke/ and die Dumper($r);
            }
        }
        if ( $diff_ignore_file ) {
            state $things_to_ignore = do {
                my %ignore_uid;
                my %ignore_name;

                my ( $in, $in_name ) = open_file_for_reading $diff_ignore_file;

                my @f = <$in>;
                close $in or die "Couldn't read '$in_name'; $!\n";
                for my $f (@f) {
                    chomp $f;
                    $f =~ s/\#.*//;
                    $f =~ s/\s+$//;
                    next if !$f;
                    if ($f =~ /^\d/) {
                        $ignore_uid{$f} = 1;
                    } else {
                        $ignore_name{lc $f} = 1;
                    }
                }
                warn "Loading ignorance table, ".(0+%ignore_uid)." uids and ".(0+%ignore_name)." names\n" if $verbose;
                warn Dumper( \%ignore_uid, \%ignore_name ) if $verbose > 2;
                [ \%ignore_uid, \%ignore_name ]
            };
            if ($things_to_ignore->[0]{$r->uid}) {
                warn sprintf "Skipping IGNORED %s [ignoring uid]\n", $r->debuginfo if $why_not;
                return 1;
            }
            if ($things_to_ignore->[1]{lc $r->name}) {
                warn sprintf "Skipping IGNORED %s [ignoring name]\n", $r->debuginfo if $why_not;
                return 1;
            }
        }
        return 0;
    }

    my $C_plain = "\e[49m";
    my $C_black = "\e[30m";
    my $C_red   = "\e[31m";
    my $C_green = "\e[32m";
    my $C_yellow= "\e[33m";
    my $C_blue  = "\e[34m";
    my $C_purple= "\e[35m";
    my $C_cyan  = "\e[34m";
    my $C_white = "\e[37m";

    my $B_plain = "\e[49m";
    my $B_black = "\e[40m";
    my $B_red   = "\e[41m";
    my $B_green = "\e[42m";
    my $B_yellow= "\e[43m";
    my $B_blue  = "\e[44m";
    my $B_purple= "\e[45m";
    my $B_cyan  = "\e[44m";
    my $B_white = "\e[47m";

    sub show_one_diff($$$$) {
        my ($out, $r1, $r2, $ofields) = @_;
        state $fmt = "%-18.18s %-32s %-3.3s %s";
        my $said_title;
        if ($r1) {
            my $name1 = $r1->name;
            my $uid1  = $r1->uid;
            my $suid1 = show_qonu($uid1);
            if ($r2) {
                my $name2 = $r2->name;
                my $uid2  = $r2->uid;
                my $suid2 = show_qonu($uid2);
                if ( $name1 ne $name2) {
                    #printf $out "\n$fmt\n", 'RENAME', $name1, '===', $name2, $suid1 || $suid2;
                    printf $out "\nRENAME #%-8s %s === %s  %s\n", $uid2 || $uid1, $name1, $name2, $suid1 || $suid2;
                    $said_title++;
                    if ( $suid1 && $suid2 && $uid1 ne $uid2 ) {
                        printf $out "$fmt  (%s === %s)\n", 'RENUMBER', $uid1, '===', $uid2, $suid1, $suid2;
                    }
                    else {
                    }
                }
                elsif ( $suid1 && $suid2 && $uid1 ne $uid2 ) {
                    printf $out "\nMODIFY #%-8s %s %s\n", $uid2, $name2, $suid2;
                    $said_title++;
                    printf $out "$fmt  (%s === %s)\n", 'RENUMBER', $uid1, '===', $uid2, $suid1, $suid2;
                }
                FIELD: for my $f ( my @zof = @$ofields ) {
                    my (@v1, @v2);
                    for my $z ( [$r1, \@v1], [$r2, \@v2] ) {
                        my $r = $z->[0];
                        my @v;
                        if (my $ff = $r->can($f)) {
                            @v = $ff->($r);
                        }
                        elsif (exists $r->{"LIST_$f"}) {
                            @v = @{ $r->{"LIST_$f"} };
                        }
                        elsif (exists $r->{$f}) {
                            @v = $r->{$f} // ();
                        }
                        else {
                            warn "Missing field '$f' in $r\n" if $verbose;
                            @v = "Missing field '$f'";
                        }
                        @{ $z->[1] } = map { split /\n/, $_ } grep { defined $_ && "$_" ne '' } @v;
                    }
                    if ( $#v1 != $#v2 || grep { $v1[$_] ne $v2[$_] } 0..$#v1 ) {
                        if (!$said_title++) {
                            printf $out "\nMODIFY #%-8s %s  %s\n", $uid2, $name2, $suid2;
                        }
                        my $said_label;
                        _diff_align { $_[0] ne '' && $_[0] eq $_[1] } @v1, @v2;
                        for my $i ( 0 .. max $#v1, $#v2 ) {
                            my $vl1 = $v1[$i] || '';
                            my $vl2 = $v2[$i] || '';
                            $f = '' if $said_label++;
                            if ( $vl1 eq '' ) {
                                if ( $vl2 eq '' ) {
                                    next if $diff_quietly;
                                    printf "$fmt\n", $f, '', 'x', '';
                                } else {
                                    printf "$C_green$fmt$C_plain\n", $f, "(add)", "â", $vl2;
                                }
                            } elsif ( $vl2 eq '' ) {
                                    printf "$C_red$fmt$C_plain\n", $f, $vl1, "â", "(del)";
                            } elsif ( $vl1 eq $vl2 ) {
                                next if $diff_quietly;
                                printf "$fmt\n", $f, $vl1, "=", $vl2;
                            } else {
                                printf "$C_yellow$fmt$C_plain\n", $f, $vl1, "â ", $vl2;
                            }
                        }
                    }
                }
            }
            else {
                # deletion
                printf $out "\nDELETE #%-8s %s  %s\n", $uid1, $name1, $suid1;
            }
        }
        else {
            if ($r2) {
                my $name2 = $r2->name;
                my $uid2  = $r2->uid;
                my $suid2 = show_qonu($uid2);
                printf $out "\nINSERT #%-8s %s  %s\n", $uid2, $name2, $suid2;
                _dump_one $out, $r2, $ofields;
            }
            else {
                printf $out "\nBROKEN: double null records\n";
                die "NOTREACHED";
            }
        }
    }

sub generate_diff($$$$$) {
    my ($out, $rr1, $in1, $rr2, $in2 ) = @_;
    $in1 ||= '(stdin)';
    $in2 ||= '(stdin)';

    warn sprintf "DIFF: comparing %u record from %s with %u records from %s\n", scalar @$rr1, $in1, scalar @$rr2, $in2 if $verbose;
    my @ofields = _choose_ofields;

    my @rr1 = preferred_sort grep { !_skip_restricted_record $_ } @$rr1;
    my @n1 = map { $_->name . '' } @rr1; my %kn1; @kn1{@n1} = 0 .. $#n1;
    my @u1 = map { $_->uid } @rr1;       my %ku1; @ku1{@u1} = 0 .. $#u1;

    my @rr2 = preferred_sort grep { !_skip_restricted_record $_ } @$rr2;
    my @n2 = map { $_->name . '' } @rr2; my %kn2; @kn2{@n2} = 0 .. $#n2;
    my @u2 = map { $_->uid } @rr2;       my %ku2; @ku2{@u2} = 0 .. $#u2;

    my $can_map_uid  = $diff_by ne 'name' && ! grep { ! $_ } @n1, @n2;
    my $can_map_name = $diff_by ne 'uid'  && ! grep { ! $_ } @u1, @u2;

    $can_map_uid or $can_map_name or die "Can map by neither UID nor Name, due to missing values of both\n";

    ( $out, my $out_name ) = _open_output $out;

    if ($can_map_uid) {
        for my $uid ( uniq @u2, @u1 ) {
            my $suid = show_qonu($uid);
            my $i1 = $ku1{$uid};
            my $r1 = defined $i1 && $rr1[$i1];
            my $i2 = $ku2{$uid};
            my $r2 = defined $i2 && $rr2[$i2];
            if ($r1) {
                $r1->uid eq $uid or die "A Missed UID #$uid in ".Dumper($r1)."\n".Dumper([\%ku1, \%kn1, \@rr1, \%ku2, \%kn2, \@rr2,]);
            }
            if ($r2) {
                $r2->uid eq $uid or die "B Missed UID #$uid in ".Dumper($r2)."\n".Dumper([\%ku1, \%kn1, \@rr1, \%ku2, \%kn2, \@rr2,]);
            }
            show_one_diff $out, $r1, $r2, \@ofields;
        }
    }
    elsif ($can_map_name) {
        for my $name ( uniq @n2, @n1 ) {
            my $i1 = $kn1{$name};
            my $r1 = defined $i1 && $rr1[$i1];
            my $i2 = $kn2{$name};
            my $r2 = defined $i2 && $rr2[$i2];

            if ($r1) {
                $r1->name eq $name or die "A Missed name '$name' in ".Dumper($r1)."\n".Dumper([\%ku1, \%kn1, \@rr1, \%ku2, \%kn2, \@rr2,]);
            }
            if ($r2) {
                $r2->name eq $name or die "A Missed name '$name' in ".Dumper($r2)."\n".Dumper([\%ku1, \%kn1, \@rr1, \%ku2, \%kn2, \@rr2,]);
            }
            show_one_diff $out, $r1, $r2, \@ofields;
        }
    }
}

################################################################################
#
# Dump records in a textual form that allows easy inspection and comparison;
# - record as blank-line separated paragraph
# - multivalue fields split into separate (identically named) fields
# - fields on separate lines
# - postal & street addresses in multiline format
#

sub diffably_dump_records($$;$) {
    my $out = shift;
    my $rr = shift;
    my $in_name = shift || '(stdin)';

    warn sprintf "DUMP: dumping %u records from %s\n", scalar @$rr, $in_name if $verbose;

    ( $out, my $out_name ) = _open_output $out;
    my @ofields = _choose_ofields;
    my @records = @$rr;
    #print Dumper(\@records);
    @records = preferred_sort @records;
    #print Dumper(\@records);
    RECORD: for my $r (@records) {
        _skip_restricted_record $r and do {
            warn sprintf "DUMP: skipping #%s (%s)\n", $r->{__source_line}, $r->{name} // '' if $verbose > 2;
            next RECORD;
        };
        print $out "\n";
        _dump_one $out, $r, \@ofields;
    }
    close $out or die "Error while writing to $out_name; $!\n";
}

################################################################################
#
# Dump records in a textual form that can be read by automail to send birthday
# greetings.
#

sub birthday_dump_records($$;$) {
    my $out = shift;
    my $rr = shift;
    my $in_name = shift || '(stdin)';

    warn sprintf "DUMP: dumping %u records from %s\n", scalar @$rr, $in_name if $verbose;

    ( $out, my $out_name ) = _open_output $out;
    my @ofields = _choose_ofields;
    my @records = @$rr;
    #print Dumper(\@records);
    @records = preferred_sort @records;
    #print Dumper(\@records);
    RECORD: for my $r (@records) {
        $r->can('gtags') && $r->gtags('suppress birthday') ||
        _skip_restricted_record $r and do {
            warn sprintf "BIRTHDAY: skipping %s\n", $r->debuginfo if $verbose > 2;
            next RECORD;
        };

        my $name = $r->name;
        if (!$name ) {
            warn "UNNAMED RECORD\n" . Dumper($r);
            next RECORD
        }
        my $bd = $r->birthdate;
        if (!$bd) {
            warn sprintf "BIRTHDAY: date not recorded %s\n", $r->debuginfo if $verbose > 2;
            next RECORD;
        }
        my ( $y, $m, $d, $ymd ) = ( $1, $2, $3, "$1$2$3" )
            if $bd =~ m#^(\d{4})\W*(\d{2})\W*(\d{2})(?:T[:0-9]{8}|\W*)$#
            || $bd =~ m#^()\W*(\d{2})\W*(\d{2})(?:T[:0-9]{8}|\W*)$#;
        if ( ! $ymd ) {
            warn sprintf "BIRTHDAY: not valid date %s\n", $r->debuginfo if $verbose > 2;
            next RECORD;
        }
        if ($r->gtags("suppress birthday")) {
            warn sprintf "BIRTHDAY: suppressing %s\n", $r->debuginfo if $verbose > 2;
            next RECORD;
        }
        if ( $suppress_adult_birthdays && $ymd le sixteen_years_ago ) {
            warn sprintf "BIRTHDAY: not-child %s\n", $r->debuginfo if $verbose > 2;
            next RECORD
        }
        my $emails = join ",", uniq $r->listed_email;
        if (!$emails) {
            warn sprintf "BIRTHDAY: email not recorded %s\n", $r->debuginfo if $verbose > 2;
            next RECORD;
        }

        my @meetings = $r->gtags( qr/^(?:listing|member)[- ]+($mm_keys_re)/ );
        @meetings = uniq @meetings if @meetings > 1;
        my $xdate = join ".", $y ? 'xdate='.$y : 'zdate=0000', $m, $d;
        my $dpat = strftime "%d-%b", 0,0,0,$d,$m-1,$y?$y-1900:2000;
        my @areas = map { "area=" . uc $_ } sort @meetings;

        printf $out "%s\n", join("\t", join(",", 'rcpt', $dpat, $xdate, @areas), $emails, $name);
    }
    close $out or die "Error while writing to $out_name; $!\n";
}

################################################################################
#
# Scan for tags, and report a summary and list of anomalies
#

sub generate_tag_report($$;$) {
    my $out = shift;
    my $rr = shift;
    my $in_name = shift || '(stdin)';

    warn sprintf "DUMP: checking tags on %u records from %s\n", scalar @$rr, $in_name if $verbose;

    ( $out, my $out_name ) = _open_output $out;
    my @records = @$rr;
    RECORD: for my $r (@records) {
        my $errors = 0;
        #
        # Check #all vs #admin #attender etc
        #
        {
        my @t = $r->gtags(qw( admin attenders child inactive meeting members newsletter-only role ));
        if (@t == 0) {
            if ( $r->gtags('all') ) {
                _dump_one $out, $r, [] if !$errors++;
                print $out "* #all without other #tags\n";
            }
        } else {
            if ( !$r->gtags('all') ) {
                _dump_one $out, $r, [] if !$errors++;
                print $out "* #tags without #all\n";
            }
            if (@t > 1) {
                _dump_one $out, $r, [] if !$errors++;
                print $out "* multiple #tags (@t)\n";
            }
        }
        }

        #
        # Check #member vs @member - xx 
        #
        {
        my @t = $r->gtags(qr(^member[- ]+(\w{2,3})[- ]+));
        if ( $r->gtags('member') ) {
            if (@t == 0) {
                _dump_one $out, $r, [] if !$errors++;
                print $out "* #member without \@member-*\n";
            }
        } else {
            if (@t > 0) {
                _dump_one $out, $r, [] if !$errors++;
                print $out "* \@member-* without #member\n";
            }
        }
        }

        #
        # Check that children are under 16
        #
        {
        my $b = $r->birthdate =~ s/\D//gr;
        my $age = die;
        if ( $r->gtags('child') ) {

                _dump_one $out, $r, [] if !$errors++;
                print $out "Birthday is $b\n";
                die;

            if ($age >= 16) {
                _dump_one $out, $r, [] if !$errors++;
                print $out "* too old to be child, age=$age\n";
            }
        } else {
            if ($b) {
                if ($age < 16) {
                    _dump_one $out, $r, [] if !$errors++;
                    print $out "* too yound to be adult, age=$age\n";
                }
            }
        }
        }

        print $out "\n" if $errors;
    }
    close $out or die "Error while writing to $out_name; $!\n";
}

################################################################################
#
# Generate a Google import csv that includes the various qdb* fields, so these
# imported records can be merged with the existing ones to incorporate those
# new fields.
#

    sub notno($) {
        (my $z) = @_;
        return defined $z && $z =~ /^[Yy1]$|^yes$/i;
    }

sub generate_qndb_map($$;$) {
    my $out = shift;
    my $rr = shift;
    my $in_name = shift || '(stdin)';
    ( $out, my $out_name ) = _open_output $out;
    my %rr = map { ( $_->uid => $_ ) } @$rr;
    print $out "Name,Group Membership,Custom Field 1 - Type,Custom Field 1 - Value,Custom Field 2 - Type,Custom Field 2 - Value,Custom Field 3 - Type,Custom Field 3 - Value\n";
    my @records = preferred_sort @$rr;
    RECORD: for my $r (@records) {
        my $fullname = $r->name || next RECORD; #die "Missing name\n".Dumper($r);
        my $qdb = $r->uid || die "missing uid\n".Dumper($r);
        my $spouse = $r->{uid_of_spouse} // die "mssing spouse-uid\n".Dumper($r); #$r->uid_of_spouse;
        my @uids_of_kids = $r->uid_of_children_under_16; #// die "missing children-uid\n".Dumper($r); #$r->uid_of_children_under_16;
        my @uids_of_parents = $r->_list('uids_of_parents');
        my @groups = '* My Contacts';
        my $l = $r->{monthly_meeting_area};
        push @groups, '@listing - '.$l if $l;
        if (my $m = $r->{formal_membership}) {
            if ( $l && substr($m,0,3) eq substr($l,0,3) && $l !~ /overseas|elsewhere/i ) {
                $m = $l;
            }
            push @groups, '@member - '.$m, '#member';
        }
        elsif ( ! notno $r->{inactive} ) {
            push @groups, '#attender';
        }
        else {
            push @groups, '#inactive';
        }
        push @groups, '!post NZ Friends' if notno $r->{nz_friends_by_post};
        push @groups, '!send NZ Friends' if notno $r->{nz_friends_by_email};
        push @groups, '@listing - YF'    if notno $r->{show_me_in_young_friends_listing};
        if (my $n = $r->{receive_local_newsletter_by_post}) {
            push @groups, '!post '.$n;
        }
        printf $out "%s,%s,qdb,%s,qdb-spouse,%s,qdb-parent,%s,qdb-child,%s\n", $fullname, join(' ::: ', @groups), $qdb, $spouse, join(' ::: ', @uids_of_parents), join(' ::: ', @uids_of_kids);
    }
    close $out or die "Error while writing to $out_name; $!\n";
}

################################################################################
#
# Generate postage labels as a printable PDF file
#     parameters: a list of tags; a description of the label layout
#
# Using "!post {tag}" as a category, select all the records from that category
# Gather all the records from all such categories
# Group them by families (spouse & children links)
# Make a label for each family:
# - Make a summary addressee line;
#   - for one person, use their full name
#   - for two people (any relationship), use "X Jones & Y Smith" or "X & Y
#     Smith" (child last, if applicable)
#   - for one adult and two or more children, use "X Jones & family"
#   - for two adults and one or more children, use "X & Y Smith & family" or "X
#     Jones & Y Smith & family"
# - Make an inclusions list from the union of all the categories that apply on
#   any of the family members
# - include the postal address; separately, the country & postcode
# Group the labels by tag-sets
# Generate PDF, generating control labels at the top of each page and before any
# change of tag-set
#

################################################################################

=head 3

Label records

The block of variable refences is a crude way of exporting the variables to the
module, rather than importing the variables from the module. Hopefully these will
be reduced or eliminated as code is tidied.

=cut

use Label::common \($evenly_squash_to_fit, $label_banner_font,
                    $label_banner_colour, $label_banner_scale,
                    $label_bottom_margin, $label_fontname, $label_fontsize,
                    $label_height, $label_left_margin,
                    $label_postcode_fontsize, $label_right_margin,
                    $label_top_margin, $label_width, $line_spacing);
use Label::blank;
use Label::map_items \($label_bottom_margin, $label_fontname, $label_height,
                       $label_left_margin, $label_right_margin,
                       $label_top_margin, $label_width, $labels_ordered_in,
                       $line_spacing, $num_labels_across, $num_labels_down);
use Label::count::total;
use Label::recipient;

    sub suppress_unwanted_records($) {
        my $rr = shift;
        if ( @$rr && $rr->[0]->isa(CSV::gmail::) ) {
            my @rr = @$rr;
            my @skips;
            push @skips, 'archive - deceased'     if $skip_deceased;
            push @skips, 'archive - unsubscribed' if $skip_unsub;
            push @skips, 'meetings'               if $skip_meetings;
            push @skips, 'suppress listing'       if $skip_suppressed_listing;
            push @skips, 'newsletters-only'       if $skip_newsletters_only;
            push @skips, 'suppress email'         if $skip_suppressed_email;
            push @skips, 'suppress post'          if $skip_suppressed_post;
            push @skips, 'explanatory texts';
            @rr = grep { ! $_->gtags(@skips) } @rr if @skips;
            @rr = grep { ! $_->gtags(qr/^archive - /) } @rr if $skip_archived;
            $rr = \@rr;
        }
        return $rr;
    }

    sub group_people_into_households($) {
        my $rr = shift;
        $rr = suppress_unwanted_records $rr;
        @$rr or return [];
        if ( 1 || $rr->[0]->can('uid') ) {
            my @households;
            my $unique_id = 0;
            my %s;
            for my $r (@$rr) {
                $s{$r->uid} and next;
                $r->{XREF_parents} and next;
                my @h = $r;
                push @h, $r->{"XREF_spouse"} if $r->{"XREF_spouse"};
                push @h, @{ $r->{"XREF_children"} } if $r->{"XREF_children"};
                $s{$_->uid}++ for @h;
                push @households, \@h;
            }
            return \@households;
        }
        elsif ( $rr->[0]->isa(CSV::gmail::) ) {
            my %households;
            for my $r (@$rr) {
                my $a = $r->postal_address or next;
                push @{$households{$a}}, $r;
            }
            return [ values %households ]
        }
        else {
            die "Can't group households of $rr->[0]";
        }
    }

sub generate_labels($$;$) {
    my $out = shift;
    my $rr = shift;
    my $in_name = shift || '(stdin)';

    # Make family groups or households
    my $households = group_people_into_households $rr;

    warn sprintf "grouped-households: %u\n", 0+@$households if $verbose;

    # Select households which have any member wanting any of the offered
    # inclusions

    @$households = grep { grep { $_->gtags(@selection_tags) } @$_; } @$households if @selection_tags;

    # Group households by which inclusions they want, and remove members of
    # households who want nothing

    my %inclusion_label; @inclusion_label{@inclusion_tags} = @inclusion_labels;

    warn sprintf "selected-households: %u\nselection-tags: [%s]\ninclusion-tags: [%s]\ninclusion-labels: [%s]\n",
            0+@$households,
            join('; ', @selection_tags),
            join('; ', @inclusion_tags),
            join('; ', @inclusion_labels)
        if $verbose;

    my $next_inclusion_group = 'E0';
    my %inclusion_groups;
    my %group_counts;
    my %inclusion_counts;
    my %households_by_inclusions;
    HOUSEHOLD: for my $hh (@$households) {
        # Which members of household are requesting at least one item?
        my @hh = @$hh;
        @hh = grep { $_->gtags(@selection_tags) } @hh if @selection_tags;
        @hh or next HOUSEHOLD;
        # Which inclusions for this household?
        my @inclusions = map { $inclusion_label{$_} }
                            grep { my $t = $_; grep { $_->gtags($t) } @hh; }
                                @inclusion_tags
            or next HOUSEHOLD;
        $hh[0]->{inclusions} = \@inclusions;
        my $postal_address = $hh[0]->postal_address;
        # What sort-order within the tag group?
        my @sort_by = qw( country postcode city suburb street streetnum );
        $hh[0]->{sort_by} = join "\t", map { $postal_address->{$_} || '' } @sort_by;
        # and done
        $hh[0]->{inclusion_group} =
        my $igroup = $inclusion_groups{join ',', @inclusions} ||= ++$next_inclusion_group;
        ++$group_counts{$igroup};
        if ( $postal_control_tag && grep { $_->gtags($postal_control_tag) } @hh ) {
            # are they overseas?
            push @inclusions, "\x{fe01}(Special Postage)";
        }
        my $group_by = join ', ', @inclusions;
        push @{$households_by_inclusions{$group_by}}, \@hh;
        ++$inclusion_counts{$_} for @inclusions;
    }

    keys %households_by_inclusions > 0 or warn "No households selected; remember to use the GMail dump rather than the Profile dump\n";

    #print "DEBUG: households_by_inclusions:\n", Dumper(\%households_by_inclusions) if $verbose > 4 && $debug;
    if ($verbose > 2) {
        for my $hh (values %households_by_inclusions) {
            for my $h (@$hh) {
                warn sprintf "NAME: %s SORT: %s INCLUDE: %s\n", $h->[0]->name, $h->[0]->{sort_by}, $h->[0]->{inclusions};
            }
        }
    }

    my $use_item_count_labels = keys %households_by_inclusions > 1;

    my @summary_labels = ( Label::count::total::->new( "Make copies",     \@inclusion_labels,            [@inclusion_counts{@inclusion_labels}]       ),
                           Label::count::total::->new( "Stuff envelopes", ['E1'..$next_inclusion_group], [@group_counts{'E1'..$next_inclusion_group}] ) );

    # Sort within each inclusion group
    @$_ = sort { $a->[0]{sort_by}  cmp $b->[0]{sort_by} } @$_ for values %households_by_inclusions;

    #print "DEBUG: sorted households_by_inclusions:\n", Dumper(\%households_by_inclusions) if $verbose > 4 && $debug;

    my $labels_per_page = $num_labels_across * $num_labels_down;

    # generate the lines to be put on each household's label, and
    # create inclusion labels
    my @labels;
    for my $group_by ( sort { @{$households_by_inclusions{$b}} <=> @{$households_by_inclusions{$a}} } keys %households_by_inclusions ) {
        my @households = @{$households_by_inclusions{$group_by}};
        my $inclusions = $households[0][0]{inclusions};
        for my $hi ( 0..$#households ) {
            my $hh = $households[$hi];
            if ($use_item_count_labels and $hi == 0 || @labels % $labels_per_page == 0) {
                my $first_label_on_page = (@labels+1) % $labels_per_page;
                if ( $first_label_on_page == 0 ) {
                    # No point putting a count-label in last position on page,
                    # where its count would be zero, so put the summary totals
                    # label here, or otherwise just leave it blank.
                    if (@summary_labels) {
                        push @labels, pop @summary_labels;
                    }
                    else {
                        push @labels, one Label::blank::;
                    }
                }
                my $last_label_on_page = min( @households-$hi+$first_label_on_page, $labels_per_page ) - 1;
                push @labels, new Label::map_items::
                                    $inclusions,
                                    $group_counts{$hh->[0]{inclusion_group}}, #scalar(@households),
                                    $hh->[0]{inclusion_group},
                                    $first_label_on_page,
                                    $last_label_on_page;
            }
            my @hh = @$hh;
            if (@hh > 2) {
                # Rearrange the list to put the parent(s) first & second; leave the
                # second slot blank if there is only one parent.
                # (a) look for uid_of_children_under_16
                my @parents = grep { $_->uid_of_children_under_16 } @hh;
                my @children = grep { !$_->uid_of_children_under_16 } @hh;
                $#parents == 0 ||
                $#parents == 1 || warn sprintf "WARNING: group for %s has %u parents and %u children", $hh[0]->name, scalar @parents, scalar @children;
                $#parents = 1;
                for (@children) {
                    # Omit surnames on children
                    my $sn = $_->{family_name};
                    $_->{formatted} =~ s/\s*$sn$//,
                    $_->{family_name} = ' '
                }
                @hh = ( @parents, @children );
                # If more than one child, just use "and family"
                if (@hh > 3) {
                    package AndFamily;
                    # This sub has static scope, which is intentional
                    sub name {
                        my $r = shift;
                        $r->{composite_name} ||= state $f =
                            new string_with_components::
                                "family",
                                family_name => '',
                                given_name => '',
                                sort_by_surname => 'zz',
                                sort_by_givenname => 'zz';
                    }
                    state $and_family = bless {};
                    @hh = (@hh[0,1], $and_family);
                }
            }
            my @names = map { $_ && $_->name } @hh;
            for (1..$#names) {
                if ( $names[$_-1]->{family_name} eq $names[$_]->{family_name} ) {
                    $names[$_-1] = $names[$_-1]->{given_name};
                }
            }
            s/\s*\([^()]*\)\s*/ /g,
            s/ (?:ex|nÃ©e*) .*// for @names;
            my $names = join ' & ', @names;
            my $postal_address = $hh[0]->postal_address;
            my $postcode = $postal_address->{postcode} || (UNIVERSAL::can($hh[0],'postcode') && $hh[0]->postcode || $hh[0]->{postcode})
                or warn sprintf "WARNING: missing postcode on %s at %s\n", $names[0], $postal_address;
            $postal_address =~ s/(.*\S)\s*\b$postcode\b/$1/ if $postcode;
            my @lines = grep {$_}
                            $names,
                            split /\s*\n/, $postal_address;
            push @labels, new Label::recipient:: ($inclusions, $postcode, @lines);
        }
    }
    if (@summary_labels) {
        push @labels, @summary_labels;
        @summary_labels = ();
    }

    #print "LABELS:\n", Dumper(\@labels) if $verbose > 4 && $debug;

    my $pq = new PDF::paginator:: ( page_size => [$page_size || ($page_width, $page_height)] );
    $page_width = $pq->{page_width};
    $page_height = $pq->{page_height};
    ($page_size) = (
        (                grep { my $ps = $paper_sizes->{$_}; near $page_width, $ps->[1], 200 and near $page_height, $ps->[0], 200 } keys %$paper_sizes ),
        ( map { $_.'R' } grep { my $ps = $paper_sizes->{$_}; near $page_width, $ps->[0], 200 and near $page_height, $ps->[1], 200 } keys %$paper_sizes ),
        ( sprintf "custom[%.2f Ã %.2f mm]", $page_height/mm, $page_width/mm ),
    );

    my $x_start = $label_left_margin + $page_left_margin;
    my $y_start = $label_top_margin  + $page_top_margin ;

    {
    my $printable_page_height = $page_height - $page_top_margin - $page_bottom_margin;
    my $printable_page_width  = $page_width  - $page_left_margin - $page_right_margin;

    $num_labels_across ||= $printable_page_width  / ($label_step_across || $label_width);
    $num_labels_down   ||= $printable_page_height / ($label_step_down   || $label_height);

    $label_step_across ||= $printable_page_width  / $num_labels_across || $label_height + $label_top_margin + $label_bottom_margin;
    $label_step_down   ||= $printable_page_height / $num_labels_down   || $label_width  + $label_left_margin + $label_right_margin;

    $label_height ||= $label_step_down   -  $label_top_margin - $label_bottom_margin;
    $label_width  ||= $label_step_across -  $label_left_margin - $label_right_margin;

    warn sprintf "First Page\n"
               . " page size: %.2fmm Ã %.2fmm (wÃh) (%s)\n"
               . " printable: %.2fmm Ã %.2fmm (wÃh)\n"
               . " labels/page: %d Ã %d (aÃd)\n"
               . " label size: %.2fmm Ã %.2fmm (wÃh)\n"
               . " label step: %.2fmm Ã %.2fmm (aÃd)\n"
               . " offset: %.2fmm Ã %.2fmm (aÃd)\n"
               ,
                $page_width/mm, $page_height/mm, $page_size,
                $printable_page_width/mm, $printable_page_height/mm,
                $num_labels_across, $num_labels_down,
                $label_width/mm, $label_height/mm,
                $label_step_across/mm, $label_step_down/mm,
                $x_start/mm, $y_start/mm,
        if $verbose;
    }

    my $printable_label_width  = $label_width  - $label_left_margin - $label_right_margin;
    my $printable_label_height = $label_height - $label_top_margin  - $label_bottom_margin;

    for my $r ( @labels ) {
        my $text = $pq->text;

        my $label_on_page = $pq->{page_item_num}++;

        my $col;
        my $row;
        if ($labels_ordered_in eq 'columns') {
            $row  = $label_on_page        % $num_labels_down;
            $col  = ($label_on_page-$row) / $num_labels_down;
        }
        else {
            $col  = $label_on_page        % $num_labels_across;
            $row  = ($label_on_page-$col) / $num_labels_across;
        }
        my $top  = $page_height - $y_start - $label_step_down   * $row;
        my $left =                $x_start + $label_step_across * $col;
        if ($use_cropbox) {
            my $right = $left + $printable_label_width;
            my $bottom = $top - $printable_label_height;
            $pq->pdf->cropbox($left, $bottom, $right, $top);
        }

        warn sprintf "Page %u label %u -> row %u/%u column %u/%u\n",
                    $pq->pages,
                    $label_on_page,
                    $row, $num_labels_across, $col, $num_labels_down if $verbose > 1;

        $r->draw_label($pq, $top, $left, $label_on_page);

        if ($label_on_page+1 >= $num_labels_across * $num_labels_down) {
            warn "Throwpage\n" if $verbose > 1;
            $pq->closepage;
        }
    }

    ( $out, my $out_name ) = _open_output $out, 1;
    warn "Writing PDF to $out_name ($out)\n";
    print {$out} $pq->stringify;
    close $out or die "Error while writing to $out_name; $!\n";
}

################################################################################

    sub is_code($) { UNIVERSAL::isa($_[0], 'CODE') }
    sub is_hash($) { UNIVERSAL::isa($_[0], 'HASH') }
    sub is_regex($) { UNIVERSAL::isa($_[0], 'Regexp') }
    sub is_array($) { UNIVERSAL::isa($_[0], 'ARRAY') }
    sub is_array_of($$;$) {
        my ($array,$chk,$all) = @_;
        is_array($array) or return 0;
        my $c = $_[1] || return 1;
        for my $elem ( @$array ) {
          # defined $elem or next;
            $c->validate($elem)       or return 0 if UNIVERSAL::can($c, 'validate');
            $c->($elem)               or return 0 if is_code($c);
            $elem =~ $c               or return 0 if is_regex($c);
            UNIVERSAL::isa($elem, $c) or return 0;
        } continue {
            $_[2] || last;
        }
        return 1;
    }
    sub is_bool($)   { my $z = $_[0]; !ref $z && $z =~ m{^[01]$} }
    sub is_number($) { my $z = $_[0]; !ref $z && $z =~ m{^\-?\d+(?:\.\d+|)$} }

    sub yn($) { $_[0] ? 'yes' : 'no' }

    #
    # some simple manglers to provide recognizably distinct data
    #
    sub rot13($)   { $_[0] =~ tr{ A-M N-Z a-m n-z 0-4 5-9 }
                                { N-Z A-M n-z a-m 5-9 0-4 }r }
    sub phoneme($) { $_[0] =~ tr{ AE OU IY BP DT FV GK SZ LR MN CQ HJ WX ao eu iy bp dt fv gk sz lr mn cq hx jw 0123456789 }
                                { EA UO YI PB TD VF KG ZS RL NM QC JH XW oa ue yi pb td vf kg zs rl nm qc xh wj 9876543210 }r }
    sub bitflip($) { $_[0] =~ s{\w}{ pack "U", (ord($&)-2^1)+1 }er }
    sub backwards($) { scalar reverse $_[0] }

    #
    # render a list in columns, with pagination
    #
    sub render_columnated_list($$$$$;$$$) {
        my ( $pq, $render_one, $render_context, $rr, $items_across, $visible, $col, $top ) = @_;
        $col //= -1;    # start at top of first column
        $top //= 0;
        if (CHECK_ARGS) {
            @_ == 6 || @_ == 8 or croak "Wrong number of args";
            UNIVERSAL::isa($pq, PDF::paginator::) or croak "arg 1 is not a PDF::paginator";
            is_code $render_one or croak "arg 2 is not a sub";
            is_hash($render_context) or croak "arg 3 is not a hashref";
            is_array    $rr               or croak         "arg 4 is not an array";
          # is_array_of $rr, CSV::gmail:: or croak sprintf "arg 4 is not an array (of GMail records); ref=%s", @$rr ? ref $rr->[0] || '(void)' : '(empty)';
            is_number $items_across or croak "arg 5 is not a number (items-across)";
            is_bool $visible or croak "arg 6 is not a bool (visible)";
            is_number $col or croak "arg 7 is not a number (column number)";
            is_number $top or croak "arg 8 is not a number (top-position)";
        }
        my $printable_page_width  = $page_width  - $page_left_margin - $page_right_margin;
        my $column_step = ($printable_page_width + $book_intercolumn_margin)  / $items_across;
        my $column_width  = $column_step - $book_intercolumn_margin;

        # running estimate of worst-case item height
        my $height_limit = 0;
        my $zi = 0;
        for my $r (@$rr) {
            my $item_height = 0;

            # Compute exact item height in advance if either (a) not visible
            # (dimensions are all that are wanted), or (b) we're getting close
            # to the bottom of the column; otherwise use an estimate based on
            # 4Ã the current worst-case.
            my $item_height_estimate = $height_limit * 4;
            if ( $top - $item_height_estimate < $page_bottom_margin || ! $visible ) {
                $item_height =
                $item_height_estimate = $render_one->( $pq, $r, $render_context, $column_width, 0 ); # INVISIBLE: only compute size
            }

            # Move to next column if there isn't enough room left for whole item
            if ( $top - $item_height_estimate < $page_bottom_margin || $col < 0 ) {
                $top  = $page_height - $page_top_margin;
                ++$col;
                # Move to next page if this page is full
                if ($col >= $items_across) {
                    warn "Throwpage\n" if $verbose > 1;
                    $pq->closepage if $visible;
                    $col = 0;
                }
            }
            if ($visible) {
                my $text = $pq->text;
                $text->fillcolor('black');
                my $left = $page_left_margin + $column_step * $col;
                (my $item_width, $item_height) = $render_one->( $pq, $r, $render_context, $column_width, 1, $top, $left ); # VISIBLE
                warn sprintf "COLUMNATION: item #%d â%.2fmm â%.2fmm â%.2fmm â%.2fmm\n", $zi++, $top/mm, $left/mm, $item_height/mm, $item_width/mm if $verbose > 2;
            }
            $top -= $item_height;
            $height_limit >= $item_height or $height_limit = $item_height;
        }
        return $col, $top;
    }

    #
    # sort and render a list, possibly in multiple orders
    #
    sub render_sorted_columnated_list($$$$$;$$$) {
        my ( $pq, $render_one, $render_context, $rr, $items_across, $visible, $col, $top ) = @_;
        $visible //= 1;
        if (CHECK_ARGS) {
            @_ == 6 or @_ == 8 or croak "Wrong number of args";
            UNIVERSAL::isa($pq, PDF::paginator::) or croak "arg 1 is not a PDF::paginator";
            is_code $render_one or croak "arg 2 is not a sub";
            is_hash($render_context) or croak "arg 3 is not a hashref";
            is_array_of($rr, CSV::gmail::) or croak "arg 4 is not an array (of GMail records)";
            is_number $items_across or croak "arg 5 is not a number";
            is_bool $visible or croak "arg 6 is not a flag (visible)";
            is_number $col or croak "arg 7 is not a number (column number)" if @_ > 6;
            is_number $top or croak "arg 8 is not a number (top-position)" if @_ > 6;
        }
        if ($book_sort_by_surname) {
            @$rr = group_by_type sort_by_surname @$rr;
            $render_context->{ORDER} = 'surname';
            ($col, $top) = render_columnated_list( $pq, $render_one, $render_context, $rr, $items_across, $visible, $col, $top );
        }
        if ($book_sort_by_givenname) {
            @$rr = group_by_type sort_by_givenname @$rr;
            $render_context->{ORDER} = 'given_name';
            ($col, $top) = render_columnated_list( $pq, $render_one, $render_context, $rr, $items_across, $visible, $col, $top );
        }
        delete $render_context->{ORDER};
        return $col, $top;
    }

    my $mtg_abbrev_len = 5;

    #
    # You get listed in MM-elsewhere if
    #  1, you're tagged for it; or
    #  2, you're a member of the MM but *not* in any WG listing within that MM (including not MM-overseas)
    #
    sub elsewhere_filter($$) {
        my ($rrr, $mm) = @_;
        $rrr or return;
        return [ grep { $_->gtags( qr/^listing[- ]+$mm[- ]+elsewhere/ )
                   || ! $_->gtags( qr/^listing[- ]+$mm/ )
                     && $_->gtags( qr/^member[- ]+$mm/ )
                    } @$rrr ];
    }

use quaker_info qw( %wg_abbrev @mm_order %mm_titles @wg_order %skip_mm_listing %skip_wg_listing );

sub generate_book($$;$) {
    my $out = shift;
    my $rr0 = shift;
    my $in_name = shift || '(stdin)';

#   use_preset 'book';

    my $rev_ymd;
    if ($in_name =~ /-((20\d\d)([01]\d)([0-3]\d))\./) {
        $rev_ymd = $1
    } else {
        $rev_ymd = strftime '%Y%m%d', localtime $^T;
        $rev_ymd =~ /^((20\d\d)([01]\d)([0-3]\d))$/;
    }
    my ($rev_year, $rev_month, $rev_day) = ($2,$3,$4);
    my $rev_dmmy = strftime "%d%b%Y", (0)x3, $rev_day, $rev_month-1, $rev_year-1900;

    my $copyright = sprintf "Compilation copyright Â©%u The Religious Society of Friends Aotearoa New Zealand, all rights reserved. For personal use only. Revised %s", $rev_year, $rev_dmmy;

    my $rr = suppress_unwanted_records $rr0;
    @$rr = grep { $_->gtags( 'members', 'attenders', 'child', 'inactive', 'meeting' ) } @$rr;

    my %by_mm;
    my %by_wg;
    for my $r (@$rr) {
        if ( my @meetings = $r->gtags( qr/^listing[- ]+((?:$mm_keys_re|YF)\b.*)/ ) ) {
            @meetings = uniq @meetings if @meetings > 1;
            for my $m (@meetings) {
                push @{$by_wg{$m}}, $r;
            }
        }
        elsif ( ! $r->gtags( 'meeting' ) ) {
            push @{$by_wg{'NO - not in any worship group'}}, $r;
        }
        if ( my @meetings = $r->gtags( qr/^(?:listing|member)[- ]+($mm_keys_re)/ ) ) {
            @meetings = uniq @meetings if @meetings > 1;
            for my $m (@meetings) {
                push @{$by_mm{$m}}, $r;
            }
        }
        elsif ( ! $r->gtags( 'meeting' ) ) {
            push @{$by_mm{'NO - not in any meeting'}}, $r;
        }
    }
    {
        # Find meeting tags, make sure they're in the "@wg_order" list
        my @wg = keys %by_wg;
        my %w1 = map { ( $_ => 1 ) } @wg;
        my %w2 = map { ( $_ => 1 ) } @wg_order;
        delete @w1{ @wg_order };
        delete @w2{ @wg };
        ! %w1 or die sprintf "WG_ORDER is missing %s\n", join ',', sort keys %w1;
        ! %w2 or warn sprintf "WG_ORDER has excess %s\n", join ',', sort keys %w2;
    }


    my $pq = new PDF::paginator:: ( page_size => [$page_size || ($page_width, $page_height)] );

    # if pagesize was given as eg "A5", convert that back to actual dimensions
    $page_width = $pq->{page_width};
    $page_height = $pq->{page_height};

    my $printable_page_height = $page_height - $page_top_margin - $page_bottom_margin;
    my $printable_page_width  = $page_width  - $page_left_margin - $page_right_margin;
    my $fontname = $book_fontname;
    my $email_fontname = $book_email_fontname;
    my $fontsize = $book_fontsize;
    my $small_fontsize = $book_fontsize; #*2/3;
    my $lineheight = $fontsize * min 1, $line_spacing/(1+$extra_para_spacing);

    warn sprintf "Pagination info\n"
               . "page size: %.2fmm Ã %.2fmm (%s)\n"
               . "printable page size: %.2fmm Ã %.2fmm\n"
               ,
                $page_width/mm, $page_height/mm, $page_size,
                $printable_page_width/mm, $printable_page_height/mm,
        if $verbose;

    my $TB   = $pq->TB;
    my $TBI  = $pq->TBI;
    my $TBIU = $pq->TBIU;
    my $TBU  = $pq->TBU;
    my $TI   = $pq->TI;
    my $TIU  = $pq->TIU;
    my $TU   = $pq->TU;
    my $TN   = $pq->TN;

    my $render_column_heading = sub {
        my ( $pq, $r, $render_context, $column_width, $visible, $top, $left ) = @_;
        if (CHECK_ARGS) {
            if ($visible) {
                @_ == 7 or croak sprintf "Wrong number of args; expected %d with 'visible', got %d", 7, 0+@_;
            } else {
                @_ == 5 or croak sprintf "Wrong number of args; expected %d with 'invisible', got %d", 5, 0+@_;
            }
            UNIVERSAL::isa($pq, PDF::paginator::) or croak "arg 1 is not a PDF::paginator";
            ! defined $r or croak "arg 2 should be undef but is not\n";
            is_hash($render_context) or croak "arg 3 is not a hashref";
            is_number $column_width or croak "arg 4 is not a number (item-width)" if @_ >= 4;
            is_bool $visible or croak "arg 5 is not a flag (visible)" if @_ >= 5;
            is_number $top or croak "arg 6 is not a number (top-position)" if $visible;
            is_number $left or croak "arg 7 is not a number (left-position)" if $visible;
        }
        if ($verbose) {
            if ($visible) {
                warn sprintf "RENDER heading â%.2fmm â%.2fmm â%.2fmm\n", $column_width/mm, $left/mm, $top/mm
                    if $verbose > 2;
            }
            else {
                warn sprintf "SIZING heading â%.2fmm\n", $column_width/mm
                    if $verbose > 2;
            }
        }

        my $heading_text = $render_context->{heading} or return 0, 0;
        $heading_text = $TB . $heading_text . $TN if $render_context->{heading_bold};

        my $heading_fontname = $render_context->{heading_font} || $fontname;
        my $heading_fontsize = $render_context->{heading_size} || $fontsize;
        my $heading_line_spacing = $render_context->{heading_spacing} || $line_spacing;
        my $text = $pq->text;
        my $item_height;

        if ( $visible ) {
            (undef, $item_height) = $pq->text_flow($heading_fontname, $heading_fontsize, $heading_line_spacing, $heading_text, $column_width, $top, $left);
        } else {
            (undef, $item_height) = $pq->text_size($heading_fontname, $heading_fontsize, $heading_line_spacing, $heading_text, $column_width);
        }
        warn sprintf "HEADING: â%.2fmm â%.2fmm â%.2fmm â%.2fmm\n", $top/mm, $left/mm, $item_height/mm, $column_width/mm if $verbose > 2;
        return $column_width, $item_height;
    };

    # Copyright
    push @{$pq->{upon_end_page}}, sub {
            my ($pq, $pagenum) = @_;
            my $right_page = $pagenum % 2;
            $pq->text_at($copyright, { fn => $book_fontname, fs => $book_pagenumber_fontsize, y => $page_height-$page_top_margin/2, x => $page_width/2, halign => 1, valign => 1, italic => 1, });
        };

    # Page numbering
    if ($use_page_numbers) {
        # Number each page
        push @{$pq->{upon_end_page}}, sub {
            my ($pq, $pagenum) = @_;
            my $right_page = $pagenum % 2;
            $pq->text_at($pagenum, { fn => $book_fontname, fs => $book_pagenumber_fontsize, y => $page_bottom_margin/2, x => $page_width/2, halign => 1, valign => 1, italic => 1, });
        };
    }

    # Margin stamping
    push @{$pq->{upon_end_page}}, sub {
            my ($pq, $pagenum) = @_;
            my $page_data = $pq->{pagedata} or return;
            my $margin_notes = $page_data->{margin_notes_list} || $page_data->{margin_notes} or return;
            my $right_page = $pagenum % 2;
            my $mm_lh = $book_margin_fontsize*$line_spacing;
            my $top =  $page_height - $page_top_margin - $mm_lh;
            my $left = $right_page ? $page_width-$page_right_margin/2
                                   : $page_left_margin/2;
            if (ref $margin_notes) {
                $margin_notes = $right_page ? join ", ",         @$margin_notes
                                            : join ", ", reverse @$margin_notes;
            }
            $pq->text_at($margin_notes, {   fn => $fontname,
                                            fs => $book_margin_fontsize,
                                            y => $top,
                                            x => $left,
                                            r => $right_page ? 3 : 1,
                                            valign => 0,
                                            halign => 1,
                                        } );
        };

    # Render the first letter of the surname of:
    #   * the FIRST record in the top-left corner of a left page,
    #   * the LAST record in the top-right corner of a right page
    # Note that this will produce gibberish if you have (parts of) more than one list on a page
    my $first_or_last_on_page = sub {
        my ($pq, $pagenum) = @_;
        my $page_data = $pq->{pagedata} or return;
        my $right_page = $pagenum % 2;
        my $mm_lh = $book_margin_fontsize*$line_spacing;
        my $top = $page_height - $page_top_margin + $mm_lh;
        my $left;
        my $from_letter = $page_data->{first}{initial};
        my $to_letter = $page_data->{last}{initial};
        my $margin_notes = join '-', $from_letter, $to_letter eq $from_letter ? () : $to_letter;
        if ($right_page) {
           #$margin_notes = $page_data->{last}{initial} || '-' ; #'R'.$pq->pagenum;
            $left = $page_width-$page_right_margin/2;
        } else {
           #$margin_notes = $page_data->{first}{initial} || '-' ; #'L'.$pq->pagenum;
            $left = $page_left_margin/2;
        }
        $pq->text_at($margin_notes, { fn => $fontname, fs => $book_margin_fontsize, y => $top, x => $left, halign => 1, });
    };

    my %detail_widths = (
        phone   => 0.20,
        name    => 0.30,
        details => 0.50, );

    my @detail_order = $book_phones_first ? qw( phone name details )
                                          : qw( name phone details );

    my @detail_offsets = (0, @detail_widths{@detail_order[0..$#detail_order-1]});
    $detail_offsets[$_] += $detail_offsets[$_-1] for 1..$#detail_offsets;

    my %detail_offsets; @detail_offsets{@detail_order} = @detail_offsets;

    #my %detail_order = map { ( $detail_order[$_] => $_ ) } 0..$#detail_order;

    my $render_person_details = sub {
        my ( $pq, $r, $render_context, $column_width, $visible, $top, $left ) = @_;
        if (CHECK_ARGS) {
            if ($visible) {
                @_ == 7 or croak sprintf "Wrong number of args; expected %d with 'visible', got %d", 7, 0+@_;
            } else {
                @_ == 5 or croak sprintf "Wrong number of args; expected %d with 'invisible', got %d", 5, 0+@_;
            }
            UNIVERSAL::isa($pq, PDF::paginator::) or croak "arg 1 is not a PDF::paginator ref";
            UNIVERSAL::isa($r, CSV::gmail::) or croak "arg 2 is not a gmail record";
            is_hash($render_context) or croak "arg 3 is not a hashref";
            is_number $column_width or croak "arg 4 is not a number (item-width)" if @_ >= 4;
            is_bool $visible or croak "arg 5 is not a flag (visible)" if @_ >= 5;
            is_number $top or croak "arg 6 is not a number (top-position)" if $visible;
            is_number $left or croak "arg 7 is not a number (left-position)" if $visible;
        }

        my $inactive = $r->gtags('inactive','child');
        my $ismeeting = $r->gtags('meeting');
        my $ismember = $r->gtags('members');
        my $name = $r->name;
        my $family_name = $name->{family_name};
        $name = "$name";
        $name =~ s/\([^()]*\)//g;

        my $page_data = $pq->{pagedata} ||= {};

        # add to margin notes
        if ( my $margin_note = $render_context->{margin_note} ) {
            if ( ! $page_data->{seen_margin_note}{$margin_note}++ ) {
                my $mn = $page_data->{margin_notes_list} ||= [];
                push @$mn, $margin_note;
            }
        }

        my $order_name = $render_context->{ORDER} eq 'surname' ? $family_name : $name;
        my $order_initial = substr $order_name, 0, 1;

        # record name info of last entry on page
        $page_data->{last} = {  initial     => $order_initial,
                                oname       => $order_name,
                                full_name   => $name,
                                family_name => $family_name, };
        # record name info of first entry on page
        $page_data->{first} ||= $page_data->{last};

        if ($name) {
            my $N = $ismember ? $TU  : $inactive ? $TI  : $TN;
            my $B = $ismember ? $TBU : $inactive ? $TBI : $TB;
            if ($ismeeting || !$family_name) {
                $name = $B.$name.$TN;
            }
            else {
                $name =~ s/(.*)($family_name)(.*)/$N$1$B$2$N$3$TN/;
            }
        }

        my @phones = map { localize_phone $_ } $r->listed_phone;
        my $emails = join " ", uniq $r->listed_email;
        my $phones = join "\n", map { s/(?<=\d) (?=\d)/\N{NBSP}/gr } @phones;
        my $addresses = join "\n", ( map { s/\n/, /gr } $r->listed_address );

        my @subcolumn_offset = map { $_ * ($column_width + $book_interdetail_spacing) } @detail_offsets{qw( phone name details )}, 1;
        my @subcolumn_width  = map { $_ * ($column_width + $book_interdetail_spacing) - $book_interdetail_spacing } @detail_widths{qw( phone name details )};
        my ($h1,$h2,$h3) = (0) x 3;
        if ($visible) {
            (undef, $h1) = $pq->text_flow($fontname, $fontsize, $line_spacing, $phones,    $subcolumn_width[0], $top, $left + $subcolumn_offset[0]);
            (undef, $h2) = $pq->text_flow($fontname, $fontsize, $line_spacing, $name,      $subcolumn_width[1], $top, $left + $subcolumn_offset[1]);
            if ($addresses) {
                (undef, my $h4) = $pq->text_flow($fontname, $fontsize, $line_spacing, $addresses, $subcolumn_width[2], $top, $left + $subcolumn_offset[2]);
                $h3 += $h4;
            }
            if ($emails) {
                (undef, my $h4) = $pq->text_flow($email_fontname, $fontsize, $line_spacing, $emails,  $subcolumn_width[2], $top-$h3, $left + $subcolumn_offset[2]);
                $h3 += $h4;
            }
        }
        else {
            (undef, $h1) = $pq->text_size($fontname, $fontsize, $line_spacing, $phones,    $subcolumn_width[0]);
            (undef, $h2) = $pq->text_size($fontname, $fontsize, $line_spacing, $name,      $subcolumn_width[1]);
            if ($addresses) {
                (undef, my $h4) = $pq->text_size($fontname, $fontsize, $line_spacing, $addresses, $subcolumn_width[2]);
                $h3 += $h4;
            }
            if ($emails) {
                (undef, my $h4) = $pq->text_size($email_fontname, $fontsize, $line_spacing, $emails, $subcolumn_width[2]);
                $h3 += $h4;
            }
        }
        my $item_height = $lineheight*$extra_para_spacing + max $h1, $h2, $h3;
        if ($verbose) {
            my $fmt = $visible ? "RENDER details â%.2fmm=%.2f*%.2f*(%.2f,%.2f,%.2f) â%.2fmm â%.2fmm â%.2fmm"
                               : "SIZING details â%.2fmm=%.2f*%.2f*(%.2f,%.2f,%.2f) â%.2fmm";
            warn sprintf "$fmt\n", $item_height/mm, ($lineheight/mm, $extra_para_spacing, $h1, $h2, $h3),
                                    $column_width/mm,
                                    ($top//0)/mm, ($left//0)/mm
                if $verbose > 2;
        }
        # create pagenum cross references for later use by indexing
        push @{$r->{_page_xrefs}}, $pq->pagenum if $visible;
        return $column_width, $item_height;
    };

    my $render_person_index = sub {
        my ( $pq, $r, $render_context, $column_width, $visible, $top, $left ) = @_;
        if (CHECK_ARGS) {
            if ($visible) {
                @_ == 7 or croak sprintf "Wrong number of args; expected %d with 'visible', got %d", 7, 0+@_;
            } else {
                @_ == 5 or croak sprintf "Wrong number of args; expected %d with 'invisible', got %d", 5, 0+@_;
            }
            UNIVERSAL::isa($pq, PDF::paginator::) or croak "arg 1 is not a PDF::paginator ref";
            UNIVERSAL::isa($r, CSV::gmail::) or croak "arg 2 is not a gmail record";
            is_hash($render_context) or croak "arg 3 is not a hashref";
            is_number $column_width or croak "arg 4 is not a number (item-width)" if @_ >= 4;
            is_bool $visible or croak "arg 5 is not a flag (visible)" if @_ >= 5;
            is_number $top or croak "arg 6 is not a number (top-position)" if $visible;
            is_number $left or croak "arg 7 is not a number (left-position)" if $visible;
        }

        # retrieve pagenum cross references
        my @page_xrefs;
        if ( $use_page_numbers ) {
            @page_xrefs = @{$r->{_page_xrefs} ||= []};
            if (@page_xrefs == 1) {
                @page_xrefs = sprintf "p.%u", @page_xrefs;
            } elsif ( @page_xrefs > 1 ) {
                @page_xrefs = sprintf "pp.%s", join ",\N{ZWNJ}", @page_xrefs;
            }
            $_ = $TI . $_ . $TN for @page_xrefs;
        }

        if ($verbose) {
            if ($visible) {
                warn sprintf "RENDER index â%.2fmm â%.2fmm â%.2fmm\n", $column_width/mm, $left/mm, $top/mm
                    if $verbose > 2;
            }
            else {
                warn sprintf "SIZING index â%.2fmm\n", $column_width/mm
                    if $verbose > 2;
            }
        }

        my $text = $pq->text;
        my $width = 0;

        my $inactive = $r->gtags('inactive','child');
        my $ismeeting = $r->gtags('meeting');
        my $ismember = $r->gtags('members');
        my $name = $r->name;
        my $family_name = $name->{family_name};
        $name = "$name";
        $name =~ s/\([^()]*\)//g;

        my $page_data = $pq->{pagedata} ||= {};

        # add to margin notes
        if ( my $margin_note = $render_context->{margin_note} ) {
            if ( ! $page_data->{seen_margin_note}{$margin_note}++ ) {
                my $mn = $page_data->{margin_notes_list} ||= [];
                push @$mn, $margin_note;
            }
        }

        my $order_name = $render_context->{ORDER} eq 'surname' ? $family_name : $name;
        my $order_initial = substr $order_name, 0, 1;

        # record name info of last entry on page
        $page_data->{last} = {  initial     => $order_initial,
                                oname       => $order_name,
                                full_name   => $name,
                                family_name => $family_name, };
        # record name info of first entry on page
        $page_data->{first} ||= $page_data->{last};

        if ($name) {
            my $N = $ismember ? $TU  : $inactive ? $TI  : $TN;
            my $B = $ismember ? $TBU : $inactive ? $TBI : $TB;
            if ($ismeeting || !$family_name) {
                $name = $B.$name.$TN;
            }
            else {
                $name =~ s/(.*)($family_name)(.*)/$N$1$B$2$N$3$TN/;
            }
        }

        my @listings = map { $wg_abbrev{$_} && $wg_abbrev{$_}[$mtg_abbrev_len] || $_ }
                           $r->gtags(qr/^listing[- ]+(\w\w\w?\b.*)/) if ! $ismeeting;

        my @phones = map { localize_phone $_ } $r->listed_phone;

        my $dat = join '  ', $name,
                             @listings,
                             @page_xrefs,
                             @phones,
                             ;

        my (undef, $item_height) = $visible ? $pq->text_flow($fontname, $fontsize, $line_spacing, $dat, $column_width, $top, $left)
                                            : $pq->text_size($fontname, $fontsize, $line_spacing, $dat, $column_width);

        warn sprintf "ITEM: â%.2fmm â%.2fmm â%.2fmm â%.2fmm\n", $top/mm, $left/mm, $item_height/mm, $column_width/mm if $verbose > 2;
        return $column_width, $item_height;
    };

    #@$rr = grep { ! $_->gtags( qr/^meeting/ ) } @$rr;       # only humans in main listing
    if ($do_book_listing_all) {
        warn "doing book LISTING - all\n" if $verbose;
        # Margin name index letters
        my %render_context = (  margin_note     => "(full alphanetical listing)",
                                heading         => "Everyone",
                                heading_bold    => 1,
                                heading_size    => $fontsize * PHI,
                             );
        push @{$pq->{upon_end_page}}, $first_or_last_on_page;   # need closepage after each group with this
        my ($col, $top) = render_columnated_list    ($pq, $render_column_heading, \%render_context, [undef], 1, 1, undef, undef);
        ($col, $top) = render_sorted_columnated_list($pq, $render_person_details, \%render_context, $rr, 1, 1, $col, $top);
        $pq->closepage;
        pop @{$pq->{upon_end_page}};
    }

    if ($do_book_listing_by_mm) {
        warn "doing book LISTING - by MM\n" if $verbose;
        push @{$pq->{upon_end_page}}, $first_or_last_on_page;   # need closepage after each group with this
        for my $mm ( @mm_order ) {
            $skip_mm_listing{$mm} and next;
            my $rrr = $by_mm{$mm} or next;
           #my $rrr = [grep { $_->gtags( qr/^(?:listing|member)[- ]+$mm/ ) } @$rr];
            warn sprintf "doing book LISTING - for MM '%s'\n", $mm if $verbose;
            my $heading = $mm_titles{$mm};
            my %render_context = (  margin_note     => $heading,
                                    heading         => $heading,
                                    heading_bold    => 1,
                                    heading_size    => $fontsize * PHI,
                                 );
            $pq->closepage;
            my ($col, $top) = render_columnated_list    ($pq, $render_column_heading, \%render_context, [undef], 1, 1, undef, undef);
            ($col, $top) = render_sorted_columnated_list($pq, $render_person_details, \%render_context, $rrr, 1, 1, $col, $top);
        }
        $pq->closepage;
        pop @{$pq->{upon_end_page}};
    }

    if ($do_book_listing_by_wg) {
        warn "doing book LISTING - by WG\n" if $verbose;
        my $col;
        my $top = 0;
        for my $wg ( @wg_order ) {
            $skip_wg_listing{$wg} and next;
            my ($mm, $heading) = split /[- ]+/, $wg, 2;
            my $margin_note = $heading //= '';

            my $rrr;
            if ( $heading eq 'elsewhere' ) {
                $rrr = elsewhere_filter $by_mm{$mm}, $mm or next;
                $heading = sprintf "%s, in other parts of NZ", $mm_titles{$mm};
                $margin_note = sprintf "%s MM in NZ", $mm;
            } else {
                $rrr = $by_wg{$wg} or next;
                if ( $heading eq 'overseas' ) {
                    $heading = sprintf "%s, overseas", $mm_titles{$mm};
                    $margin_note = sprintf "%s MM overseas", $mm;
                } elsif ($mm eq 'YF') {
                    $heading = join ' ', 'Young Friends', $heading || ();
                }
            }

            warn sprintf "doing book LISTING - for WG '%s'\n", $heading if $verbose;

            my %render_context = (  margin_note     => $margin_note,
                                    heading         => $heading,
                                    heading_bold    => 1,
                                    heading_size    => $fontsize * PHI,
                                 );
            if ( $top < $fontsize*$line_spacing*(6+@$rrr/2) ) { $top = 0 }    # skip to next column if not enough room for 6 lines or if the following list is "large"
            else { $top -= $fontsize*$line_spacing*2 }              # leave 2 blank lines between end of previous group and heading for next group
            ($col, $top) = render_columnated_list       ($pq, $render_column_heading, \%render_context, [undef], 1, 1, $col, $top);
            ($col, $top) = render_sorted_columnated_list($pq, $render_person_details, \%render_context, $rrr, 1, 1, $col, $top);

          # $pq->closepage; $col = -1; $top = 0;
        }
        $pq->closepage;
    }

    if ($do_book_index_all) {
        warn "doing book INDEX - all\n" if $verbose;
        # Margin name index letters
        push @{$pq->{upon_end_page}}, $first_or_last_on_page;   # need closepage after each group with this
        my %render_context = (  margin_note     => "full alphanetical index",
                                heading         => "Everyone",
                                heading_bold    => 1,
                                heading_size    => $fontsize * PHI,
                             );
        my ($col, $top) = render_columnated_list    ($pq, $render_column_heading, \%render_context, [undef], 1, 1, undef, undef);
        ($col, $top) = render_sorted_columnated_list($pq, $render_person_index, \%render_context, $rr, 3, 1, $col, $top);
        $pq->closepage;
        pop @{$pq->{upon_end_page}};
    }

    if ($do_book_index_by_mm) {
        warn "doing book INDEX - by MM\n" if $verbose;
        push @{$pq->{upon_end_page}}, $first_or_last_on_page;   # need closepage after each group with this
        for my $mm ( @mm_order ) {
            $skip_mm_listing{$mm} and next;
            warn sprintf "doing book INDEX - for MM '%s'\n", $mm if $verbose;
            my $rrr = $by_mm{$mm} or next;
            $pq->closepage;
            my $h = $mm_titles{$mm};
            my %render_context = (  margin_note     => $h,
                                    heading         => $h,
                                    heading_bold    => 1,
                                    heading_size    => $fontsize * PHI,
                                 );
            my ($col, $top) = render_columnated_list    ($pq, $render_column_heading, \%render_context, [undef], 1, 1, undef, undef);
            ($col, $top) = render_sorted_columnated_list($pq, $render_person_index, \%render_context, $rrr, 3, 1, $col, $top);
            $pq->closepage;
        }
        pop @{$pq->{upon_end_page}};
    }

    if ($do_book_index_by_wg) {
        warn "doing book INDEX - by WG\n" if $verbose;
        my $col;
        my $top = 0;
        for my $wg ( @wg_order ) {
            $skip_wg_listing{$wg} and next;
            my ($mm, $heading) = split /[- ]+/, $wg, 2;
            my $margin_note = $heading;

            my $rrr;
            if ( $heading eq 'elsewhere' ) {
                $rrr = elsewhere_filter $by_mm{$mm}, $mm or next;
                $heading = sprintf "%s, in other parts of NZ", $mm_titles{$mm};
                $margin_note = sprintf "%s MM in NZ", $mm;
            } else {
                $rrr = $by_wg{$wg} or next;
                if ( $heading eq 'overseas' ) {
                    $heading = sprintf "%s, overseas", $mm_titles{$mm};
                    $margin_note = sprintf "%s MM overseas", $mm;
                } elsif ($mm eq 'YF') {
                    $heading = join ' ', 'Young Friends', $heading || ();
                }
            }

            warn sprintf "doing book INDEX - for WG '%s'\n", $heading if $verbose;

            my %render_context = (  margin_note     => $margin_note,
                                    heading         => $heading,
                                    heading_bold    => 1,
                                    heading_size    => $fontsize * PHI,
                                 );
            if ( $top < $fontsize*$line_spacing*(6+@$rrr/2) ) { $top = 0 }    # skip to next column if not enough room for 6 lines or if the following list is "large"
            else { $top -= $fontsize*$line_spacing*2 }              # leave 2 blank lines between end of previous group and heading for next group
            ($col, $top) = render_columnated_list       ($pq, $render_column_heading, \%render_context, [undef], 3, 1, $col, $top);
            ($col, $top) = render_sorted_columnated_list($pq, $render_person_index, \%render_context, $rrr, 3, 1, $col, $top);

          # $pq->closepage; $col = -1; $top = 0;
        }
        $pq->closepage;
    }

    $pq->closepage;
    delete $pq->{upon_end_page};

    ( $out, my $out_name ) = _open_output $out, 1;
    print "Writing PDF to $out_name ($out)\n";
    print {$out} $pq->stringify;
    close $out or die "Error while writing to $out_name; $!\n";
}
};

sub generate_test($) {
    my $out = shift;

    my $pq = new PDF::paginator:: ( page_size => [$page_size || ($page_width, $page_height)] );

    # if pagesize was given as eg "A5", convert that back to actual dimensions
    $page_width = $pq->{page_width};
    $page_height = $pq->{page_height};

    my $printable_page_height = $page_height - $page_top_margin - $page_bottom_margin;
    my $printable_page_width  = $page_width  - $page_left_margin - $page_right_margin;
    my $fontname = $book_fontname;
    my $fontsize = $book_fontsize;
    my $lineheight = $fontsize * min 1, $line_spacing/(1+$extra_para_spacing);

    warn sprintf "Pagination info\n"
               . "page size: %.2fmm Ã %.2fmm (%s)\n"
               . "printable page size: %.2fmm Ã %.2fmm\n"
               ,
                $page_width/mm, $page_height/mm, $page_size,
                $printable_page_width/mm, $printable_page_height/mm,
        if $verbose;

    for my $v ( 0..2 ) {
        for my $h ( 0..2 ) {
            for my $r ( 0..3 ) {
                $pq->text_at( sprintf('test text r=%s h=%s v=%s', $r, $h, $v),
                              x => $page_width/2,
                              y => $page_height/2,
                              fn => $book_fontname,
                              fs => 72*pt,
                              r => $r+0.5,
                              halign => $h,
                              valign => $v,
                            );
            }
    $pq->closepage;
        }
    }
    $pq->closepage;
    delete $pq->{upon_end_page};

    ( $out, my $out_name ) = _open_output $out, 1;
    print "Writing PDF to $out_name ($out)\n";
    print {$out} $pq->stringify;
    close $out or die "Error while writing to $out_name; $!\n";
}

################################################################################

#
# Sanity-check command-line args
#

$do_test || $do_book || $do_diff || $do_birthday_dump || $do_diffable_dump || $do_tag_report || $do_labels || $do_qndb_map or die "Need at least one of: --book-* --labels --diff --dump --qndb-map\n";

#
# Actual work...
#

if ($do_test) {
    my $o = $output_name || ( $force_overwrite = -1,    # it's only a test file, after all;
                              'test.pdf' );
    generate_test( $o );
}
elsif ($do_diff) {
    $do_book || $do_birthday_dump || $do_diffable_dump || $do_tag_report || $do_labels || $do_qndb_map and die "Can't combine --diff with anything else\n";

    my $f1 = shift @ARGV;
    my $f2 = shift @ARGV || '-';
    @ARGV == 0 or die "Need two files (or one file and stdin) with --diff\n";
    my $rr1 = parse_file $f1;
    my $rr2 = parse_file $f2;
    generate_diff( $output_name, $rr1, $f1, $rr2, $f2 );
}
else {
    if (!@ARGV) {
        @ARGV = '-';
        $output_name ||= '-';
    }
    ! $output_name or
    $do_book + $do_labels + $do_birthday_dump + $do_diffable_dump + $do_tag_report + $do_qndb_map == 1 or die "Only one function allowed with --output\n";

    for my $a (@ARGV) {
        my $rr = parse_file $a;
    #   warn Dumper($rr) if $verbose > 4 && $debug;
        if ($do_book) {
            # Force overwrite if the output filename is related to (but not the same as) the input filename
            my $o = $output_name || ( $force_overwrite ||= -1, $a =~ s/(?:\.\w+|)$/-book.pdf/r );
            $o ne '-' && $o eq $a && $force_overwrite < 1 && die "Can't overwrite input file as output file\n";
            generate_book( $o, $rr, $a );
        }
        if ($do_labels) {
            # extra sanity-check
            $labels_ordered_in eq 'columns' || $labels_ordered_in eq 'rows' || die "Label ordering must be 'rows' or 'columns'\n";
            # Force overwrite if the output filename is related to (but not the same as) the input filename
            my $o = $output_name || ( $force_overwrite ||= -1, $a =~ s/(?:\.\w+|)$/\.pdf/r );
            $o ne '-' && $o eq $a && $force_overwrite < 1 && die "Can't overwrite input file as output file\n";
            generate_labels( $o, $rr, $a );
        }
        if ($do_birthday_dump) {
            my $o = $output_name || '-';
            birthday_dump_records( $o, $rr, $a );
        }
        if ($do_diffable_dump) {
            my $o = $output_name || '-';
            diffably_dump_records( $o, $rr, $a );
        }
        if ($do_tag_report) {
            # Force overwrite if the output filename is related to (but not the same as) the input filename
            my $o = $output_name || '-';
            $o ne '-' && $o eq $a && $force_overwrite < 1 && die "Can't overwrite input file as output file\n";
            generate_tag_report( $o, $rr, $a );
        }
        if ($do_qndb_map) {
            # Force overwrite if the output filename is related to (but not the same as) the input filename
            my $o = $output_name || ( $force_overwrite ||= -1, $a =~ s/(?:\.\w+|)$/-qdb.csv/r );
            $o ne '-' && $o eq $a && $force_overwrite < 1 && die "Can't overwrite input file as output file\n";
            generate_qndb_map( $o, $rr, $a );
        }
    }
}

1;

__END__

Set the global mediabox                     Set the global cropbox                      Set the global bleedbox                     Set the global trimbox                      Set the global artbox

->mediabox($name)                           ->cropbox($name)                            ->bleedbox($name)                           ->trimbox($name)                            ->artbox($name)
->mediabox($width, $height)                 ->cropbox($width, $height)                  ->bleedbox($width, $height)                 ->trimbox($width, $height)                  ->artbox($width, $height)
->mediabox($left, $bottom, $right, $top)    ->cropbox($left, $bottom, $right, $top)     ->bleedbox($left, $bottom, $right, $top)    ->trimbox($left, $bottom, $right, $top)     ->artbox($left, $bottom, $right, $top)

Examples:

   $pdf->mediabox('A4');
   $pdf->mediabox(595, 842);
   $pdf->mediabox(0, 0, 595, 842);

